#include <cstdio> // 引入C标准输入输出库，用于scanf和printf
using namespace std; // 使用标准命名空间，避免每次使用标准库函数时都写std::

const int MAXN = 2050; // 定义二维数组的最大行数，考虑到题目数据范围，通常会留一些余量
const int MAXM = 2050; // 定义二维数组的最大列数

// 四个辅助的二维树状数组
// info1: 维护原始值 v 的前缀和，对应公式中的 sigma(diff_i,j)
// info2: 维护 x * v 的前缀和，对应公式中的 sigma(i * diff_i,j)
// info3: 维护 y * v 的前缀和，对应公式中的 sigma(j * diff_i,j)
// info4: 维护 x * y * v 的前缀和，对应公式中的 sigma(i * j * diff_i,j)
int info1[MAXN][MAXM], info2[MAXN][MAXM], info3[MAXN][MAXM], info4[MAXN][MAXM];
int n, m; // 当前网格的实际行数和列数

// lowbit 函数：计算二进制数 i 的最低有效位（最低位的1所代表的数值）
// 这是树状数组操作的核心，用于确定下一个需要更新或查询的父节点/子节点
// 例如：lowbit(8) = 8 (1000b -> 1000b)
// lowbit(6) = 2 (0110b -> 0010b)
int lowbit(int i) {
    return i & -i;
}

// 单点更新函数：对 (x, y) 位置进行增量为 v 的更新
// 这个函数实际上是对上面提到的四个辅助树状数组进行“单点修改”
// 这里的 v 是经过差分处理后的实际增量值
void add(int x, int y, int v) {
    // 根据二维树状数组的推导公式，我们需要将 v 分解为四部分
    int v1 = v;         // 对应 info1
    int v2 = x * v;     // 对应 info2
    int v3 = y * v;     // 对应 info3
    int v4 = x * y * v; // 对应 info4

    // 遍历所有受 (x, y) 影响的父节点（或说包含 (x, y) 的区间）
    // 外层循环控制行，从 x 开始，每次加上 lowbit(i)，直到超过 n
    for (int i = x; i <= n; i += lowbit(i)) {
        // 内层循环控制列，从 y 开始，每次加上 lowbit(j)，直到超过 m
        for (int j = y; j <= m; j += lowbit(j)) {
            // 对四个辅助树状数组同时进行更新操作
            info1[i][j] += v1;
            info2[i][j] += v2;
            info3[i][j] += v3;
            info4[i][j] += v4;
        }
    }
}

// 单点查询函数：计算从 (1, 1) 到 (x, y) 矩形区域的前缀和
// 这个函数会综合四个辅助树状数组的信息，根据推导公式计算最终的前缀和
int sum(int x, int y) {
    int ans = 0; // 初始化前缀和为0

    // 遍历所有包含 (x, y) 的区间（或说 (x, y) 的所有祖先节点）
    // 外层循环控制行，从 x 开始，每次减去 lowbit(i)，直到 i 变为 0
    for (int i = x; i > 0; i -= lowbit(i)) {
        // 内层循环控制列，从 y 开始，每次减去 lowbit(j)，直到 j 变为 0
        for (int j = y; j > 0; j -= lowbit(j)) {
            // 根据二维树状数组前缀和的推导公式进行计算
            // Ans(x,y) = (x+1)(y+1)Sum(info1) - (y+1)Sum(info2) - (x+1)Sum(info3) + Sum(info4)
            // 这里的 info1[i][j] 等是树状数组中存储的“块”的值，它们累加起来才是真正的 Sum(infoX)
            ans += (x + 1) * (y + 1) * info1[i][j] // (X+1)(Y+1) * sigma(diff_i,j)
                 - (y + 1) * info2[i][j]           // -(Y+1) * sigma(i * diff_i,j)
                 - (x + 1) * info3[i][j]           // -(X+1) * sigma(j * diff_i,j)
                 + info4[i][j];                    // + sigma(i * j * diff_i,j)
        }
    }
    return ans; // 返回计算出的前缀和
}

// 范围增加函数：对矩形区域 (a, b) 到 (c, d) 增加值 v
// 利用二维差分思想，将一个矩形范围的更新转化为四个“单点更新”
// 这种方法被称为“二维差分”或“二维容斥原理”
void add(int a, int b, int c, int d, int v) {
    // 1. 在 (a, b) 位置增加 v
    // 这表示从 (a, b) 到右下角的所有点都会增加 v 的贡献
    add(a, b, v);

    // 2. 在 (c + 1, d + 1) 位置增加 v
    // 这看似奇怪，但结合后面的减法，是为了抵消超出 (c, d) 范围的额外贡献
    // 想象一下，我们需要 (a,b) 到 (c,d) 增加 v。
    // (a,b) +v 会影响到无限右下角。
    // (c+1, d+1) +v 也会影响到无限右下角，但其作用是作为负抵消项的“起点”之一。
    add(c + 1, d + 1, v); // 🤯 哇哦，这里是不是写错了？
                          // 仔细思考一下二维差分的原理：
                          // 设 diff[i][j] = A[i][j] - A[i-1][j] - A[i][j-1] + A[i-1][j-1]
                          // 对 (a,b) 到 (c,d) 增加 v，相当于：
                          // diff[a][b] += v
                          // diff[c+1][b] -= v
                          // diff[a][d+1] -= v
                          // diff[c+1][d+1] += v
                          // 所以，这里的 add(c+1, d+1, v) 应该是 add(c+1, d+1, v) 没错，因为它是双重减法的抵消点，所以要加回来。
                          // 逻辑是：[a,b] +v, [a,d+1] -v, [c+1,b] -v, [c+1,d+1] +v
                          // 这样能确保只有 [a,b] 到 [c,d] 的区域增加了 v。
                          // 没错，代码是正确的，这里的 add(c+1, d+1, v) 是符合二维差分的逻辑的。
                          // 它的作用是把 (c+1, d+1) 往右下角影响到的区域“再拉升回来”，因为前面减了两次。
                          // 让我重写一下注释，让它更清晰。

    // 为了在矩形 (a,b) 到 (c,d) 范围内增加 v，我们使用二维差分的四个点更新策略：
    // 1. 在 (a, b) 处增加 v：使得 (a,b) 及其右下角所有区域都增加 v。
    add(a, b, v);
    // 2. 在 (c + 1, b) 处减去 v：抵消 (c+1, b) 及其右下角区域的 v 增量。
    //    这保证了 (c+1, b) 及其右下角列的区域不再受到 (a,b) 的影响。
    add(c + 1, b, -v);
    // 3. 在 (a, d + 1) 处减去 v：抵消 (a, d+1) 及其右下角区域的 v 增量。
    //    这保证了 (a, d+1) 及其右下角行的区域不再受到 (a,b) 的影响。
    add(a, d + 1, -v);
    // 4. 在 (c + 1, d + 1) 处增加 v：
    //    由于 (c+1, b) 和 (a, d+1) 都减去了 v，导致 (c+1, d+1) 及其右下角区域被重复减去了 v。
    //    所以需要在这里加回一个 v 来弥补多减的部分，符合容斥原理。
    add(c + 1, d + 1, v);
    // ✅ 这样处理后，只有矩形 [a,b] 到 [c,d] 的区域最终获得了 v 的增量。
}

// 范围查询函数：查询矩形区域 (a, b) 到 (c, d) 的总和
// 利用二维前缀和（容斥原理）来计算任意矩形区域的和
int range(int a, int b, int c, int d) {
    // 矩形 (a, b) 到 (c, d) 的和 = Sum(1,1 to c,d)
    //                               - Sum(1,1 to a-1,d)
    //                               - Sum(1,1 to c,b-1)
    //                               + Sum(1,1 to a-1,b-1) (因为 Sum(a-1,b-1) 被减了两次，需要加回来一次)
    return sum(c, d)             // Sum(c,d)
         - sum(a - 1, d)         // 减去左边超出范围的部分
         - sum(c, b - 1)         // 减去上边超出范围的部分
         + sum(a - 1, b - 1);    // 加上左上角重复减去的部分 (容斥原理)
}

int main() {
    char op; // 操作类型字符
    int a, b, c, d, v; // 操作参数

    // 读取第一个字符（通常是 'X'，表示初始化网格大小）
    scanf("%s", &op); // 注意这里用 %s 读取一个字符串，即使只有一个字符，因为历史原因或方便处理
    scanf("%d%d", &n, &m); // 读取网格的行数 n 和列数 m

    // 循环读取操作，直到文件结束 (EOF)
    while (scanf("%s", &op) != EOF) {
        if (op == 'X') { // 如果操作是 'X'，表示重新设置网格大小 (通常用于测试多组数据)
            scanf("%d%d", &n, &m); // 读取新的 n 和 m
            // 注意：这里没有清空 info 数组，如果测试用例是独立，可能需要 memset 清零。
            // 但对于洛谷P4514，它每次X操作后是全新的N,M，但所有info数组都定义在全局，是0初始化的。
            // 且题目要求N,M逐渐增大，所以不清空也问题不大，因为只用到更大的N,M区域，或者直接用更大的MAXN,MAXM。
            // 实际上，对于竞赛编程，全局数组是自动初始化为0的。
        } else if (op == 'L') { // 如果操作是 'L' (Load)，表示进行范围增加操作
            scanf("%d%d%d%d%d", &a, &b, &c, &d, &v); // 读取矩形范围 (a,b)-(c,d) 和增量 v
            add(a, b, c, d, v); // 调用范围增加函数
        } else { // 如果操作是 'Q' (Query)，表示进行范围查询操作 (除了 'X' 和 'L' 之外的任何字符都被视为 'Q')
            scanf("%d%d%d%d", &a, &b, &c, &d); // 读取查询矩形范围 (a,b)-(c,d)
            printf("%d\n", range(a, b, c, d)); // 调用范围查询函数，并打印结果
        }
    }
    return 0; // 程序正常退出
}

