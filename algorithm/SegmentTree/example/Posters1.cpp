#include <cstdio> // 引入标准输入输出库，用于scanf和printf
#include <algorithm> // 引入算法库，用于sort和unique函数
#include <cstring> // 引入字符串处理库，用于memset函数

// 贴海报
// 有一面墙，有固定高度，长度为n，有m张海报，所有海报的高度都和墙的高度相同
// 从第1张海报开始，一张一张往墙上贴，直到n张海报贴完
// 每张海报都给出张贴位置(xi, yi)，表示第i张海报从墙的左边界xi一直延伸到右边界yi
// 有可能发生后面的海报把前面的海报完全覆盖，导致看不到的情况
// 当所有海报贴完，返回能看到海报的数量，哪怕只漏出一点的海报都算
// 1 <= n、xi、yi <= 10^7，1 <= m <= 10^3
// 测试链接 : https://www.luogu.com.cn/problem/P3740

using namespace std; // 使用标准命名空间，避免每次写std::

const int MAXM = 1001; // 定义最大海报数量。由于每个海报有左右边界，离散化后的点数可能达到2*MAXM甚至更多。
int pl[MAXM], pr[MAXM]; // pl[i]和pr[i]分别存储第i张海报的左边界和右边界
int num[MAXM << 2]; // 离散化数组：存储所有需要关注的坐标点（包括海报边界和中间点）。MAXM << 2 约等于 MAXM * 4，预留足够空间。
int poster[MAXM << 4]; // 线段树数组：每个节点存储其代表区间被哪张海报覆盖的ID。MAXM << 4 约等于 MAXM * 16，为线段树预留更充裕的空间。
bool visited[MAXM]; // 海报访问标记：在查询时，用于标记某个海报ID是否已经被统计过为可见，避免重复计数。
int size; // 离散化后实际的有效坐标点（线段树叶子节点）的数量

// 离散化函数：收集所有关键坐标点，排序，去重，并插入中间点
// 参数cnt：当前num数组中已经收集的坐标点数量
void collect(int cnt) {
    sort(num, num + cnt); // 对所有收集到的坐标点进行排序
    // unique函数将重复的元素移动到数组末尾，并返回不重复部分的结束迭代器。
    // sz记录不重复元素的数量。
    int sz = unique(num, num + cnt) - num;

    int tmp = sz; // 暂存当前不重复元素的数量
    // 遍历已去重的坐标点，插入中间点。
    // 如果num[i-1]和num[i]之间存在大于1的间隔，说明它们之间有未被表示的整数点，
    // 例如，如果num[i-1]=5, num[i]=10，那么6,7,8,9这些点需要被考虑到，至少插入num[i-1]+1 = 6这个点
    // 确保线段树的叶子节点能代表长度为1的最小区间
    for (int i = 1; i < tmp; i++) {
        if (num[i - 1] + 1 < num[i]) {
            num[sz++] = num[i - 1] + 1; // 插入中间点，使其成为一个新的离散化点
        }
    }
    // 重新排序，因为插入的中间点可能打乱了顺序
    sort(num, num + sz);
    size = sz; // 更新离散化后实际的点数（线段树的有效叶子节点数量）
}

// 二分查找离散化位置：将原始坐标v映射到离散化后的索引
// 参数v：原始坐标值
// 返回值：v在num数组中的索引，即离散化后的“排名”
int binary_rank(int v) {
    int l = 0, r = size - 1; // 在离散化后的坐标范围内进行二分查找
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (num[mid] >= v) { // 如果中间值大于等于v，说明v可能在左半部分或就是mid
            r = mid - 1;
        } else { // 如果中间值小于v，说明v在右半部分
            l = mid + 1;
        }
    }
    return l; // 返回v的离散化索引（rank），即第一个大于等于v的元素的索引
}

// 线段树下推标记（Lazy Propagation）
// 参数i：当前节点的索引
void down(int i) {
    // 如果当前节点有懒惰标记（即poster[i]不为0，表示该区间被poster[i]号海报完全覆盖）
    if (poster[i]) {
        // 将父节点的懒惰标记下推给左子节点
        poster[i << 1] = poster[i];
        // 将父节点的懒惰标记下推给右子节点
        poster[i << 1 | 1] = poster[i];
        // 清除当前节点的懒惰标记（设为0），表示已下推
        poster[i] = 0;
    }
}

// 构建线段树函数
// 参数l：当前节点代表区间的左边界（离散化索引）
// 参数r：当前节点代表区间的右边界（离散化索引）
// 参数i：当前节点的索引
void build(int l, int r, int i) {
    poster[i] = 0; // 初始化当前节点的poster ID为0，表示未被任何海报覆盖
    if (l != r) { // 如果不是叶子节点，则递归构建子树
        int mid = (l + r) >> 1; // 计算中间点
        build(l, mid, i << 1);     // 递归构建左子树
        build(mid + 1, r, i << 1 | 1); // 递归构建右子树
    }
}

// 更新线段树：将jobl到jobr离散化区间覆盖上jobv号海报
// 这是区间赋值操作，利用懒惰标记
// 参数jobl：待更新区间的左边界（用户请求的离散化索引）
// 参数jobr：待更新区间的右边界（用户请求的离散化索引）
// 参数jobv：更新的目标海报ID
// 参数l：当前节点代表区间的左边界（线段树的离散化索引）
// 参数r：当前节点代表区间的右边界（线段树的离散化索引）
// 参数i：当前节点的索引
void update(int jobl, int jobr, int jobv, int l, int r, int i) {
    // 如果当前节点代表的区间 [l, r] 完全包含在待更新区间 [jobl, jobr] 内
    if (jobl <= l && r <= jobr) {
        poster[i] = jobv; // 直接将当前节点标记为被jobv号海报覆盖
        return; // 返回，不再向下递归，因为这个标记是懒惰标记，会在需要时才下推
    }
    down(i); // 在递归更新子节点之前，需要先将当前节点的懒惰标记下推给子节点
    int mid = (l + r) >> 1; // 计算中间点
    // 如果待更新区间的左边界在左子节点区间内，递归更新左子树
    if (jobl <= mid) {
        update(jobl, jobr, jobv, l, mid, i << 1);
    }
    // 如果待更新区间的右边界在右子节点区间内，递归更新右子树
    if (jobr > mid) {
        update(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
    }
    // 注意：这里不需要up(i)操作。因为这是区间赋值（覆盖）操作，
    // 父节点的值不是由子节点简单聚合而来，而是由下推决定。
    // 只有当查询遇到未完全覆盖的节点时，才会向下查找具体叶子节点的值。
}

// 查询可见海报数量函数
// 这个查询是一个特殊的查询，它需要遍历线段树的叶子节点来识别不同的海报ID
// 参数jobl：待查询区间的左边界（用户请求的离散化索引）
// 参数jobr：待查询区间的右边界（用户请求的离散化索引）
// 参数l：当前节点代表区间的左边界（线段树的离散化索引）
// 参数r：当前节点代表区间的右边界（线段树的离散化索引）
// 参数i：当前节点的索引
int query(int jobl, int jobr, int l, int r, int i) {
    // 终止条件：如果当前节点是叶子节点
    if (l == r) {
        // 如果这个叶子节点被某张海报覆盖（poster[i] != 0），并且这张海报之前没有被统计过
        if (poster[i] && !visited[poster[i]]) {
            visited[poster[i]] = true; // 标记这张海报为已访问（已统计）
            return 1; // 计数为1，表示发现了一张新的可见海报
        }
        return 0; // 否则（没有海报或已统计过），计数为0
    }

    down(i); // 在递归查询子节点之前，需要先将当前节点的懒惰标记下推给子节点
    int mid = (l + r) >> 1; // 计算中间点
    int ans = 0; // 初始化可见海报数量

    // 如果待查询区间的左边界在左子节点区间内，递归查询左子树
    if (jobl <= mid) {
        ans += query(jobl, jobr, l, mid, i << 1);
    }
    // 如果待查询区间的右边界在右子节点区间内，递归查询右子树
    if (jobr > mid) {
        ans += query(jobl, jobr, mid + 1, r, i << 1 | 1);
    }
    return ans; // 返回统计到的可见海报总数
}

// 主函数
int main() {
    int n, m; // 定义变量：墙的长度n，海报数量m
    scanf("%d%d", &n, &m); // 读取墙的长度和海报数量

    int cnt = 0; // 记录需要离散化的坐标点数量
    num[cnt++] = 0; // 墙的左边界（起始点0）也需要离散化
    num[cnt++] = n;  // 将墙的右边界加入到离散化数组中

    // 读取每张海报的左右边界，并将它们也加入到离散化数组中
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &pl[i], &pr[i]);
        num[cnt++] = pl[i];
        num[cnt++] = pr[i];
    }

    collect(cnt);    // 对所有收集到的坐标点进行离散化处理
    build(0, size - 1, 1);  // 构建线段树，操作范围是离散化后的索引 [0, size-1]

    // 按照海报的顺序依次贴到墙上（更新线段树）
    // 由于是后贴的覆盖先贴的，所以这里从1到m的顺序是正确的
    for (int i = 1; i <= m; i++) {
        // 将海报的原始边界坐标转换为离散化后的索引
        int l = binary_rank(pl[i]);
        int r = binary_rank(pr[i]);
        // 更新线段树，将[l, r]区间覆盖上第i号海报
        update(l, r, i, 0, size - 1, 1);
    }

    // 查询整个墙面上的可见海报数量
    // 墙的左边界离散化后是0，右边界n离散化后需要查询其对应索引
    int pos_n = binary_rank(n); // 获取墙的右边界n在离散化后的索引
    memset(visited, 0, sizeof(visited)); // 在查询前，清空visited数组，确保重新开始计数
    printf("%d\n", query(0, pos_n, 0, size - 1, 1)); // 从离散化后的0到pos_n进行查询并打印结果

    return 0; // 程序正常结束
}
