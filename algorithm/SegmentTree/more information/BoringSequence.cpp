#include <cstdio>       // 引入标准输入输出库，用于scanf和printf等函数
#include <algorithm>    // 引入算法库，虽然在这个特定代码中没有直接使用，但通常是C++编程的常用工具
using namespace std;    // 使用标准命名空间，避免每次调用标准库函数时都加上std::前缀


// 无聊的数列
// 给定一个长度为n的数组arr，实现如下两种操作
// 操作 1 l r k d : arr[l..r]范围上的数依次加上等差数列，首项k，公差d
// 操作 2 p       : 查询arr[p]的值
// 测试链接 : https://www.luogu.com.cn/problem/P1438

// 定义一个常量MAXN，表示数组的最大尺寸。
// 通常设为略大于题目给出的最大数据范围，以防止越界，这里是100001，意味着最大支持10万个元素。
const int MAXN = 100001;

// --- 全局数据结构定义 ---

// diff数组：这是核心的差分数组。
// diff[i] 存储的是原数组（我们实际上不直接存储原数组）中 A[i] - A[i-1] 的值。
// 通过维护差分数组，我们可以将原数组的区间修改转化为差分数组的少数点修改。
int diff[MAXN];

// sum数组：线段树的节点存储数据。sum[i] 存储的是线段树中第 i 个节点所代表区间内所有差分值的和。
// 由于线段树通常需要4倍于原数组大小的空间，所以用 MAXN << 2 (即 MAXN * 4) 来预留空间。
long long sum[MAXN << 2];

// add数组：线段树的懒标记（Lazy Tag）。add[i] 存储的是线段树中第 i 个节点所代表区间需要额外增加的值。
// 当区间更新操作涉及到一个节点时，如果该节点对应的区间完全被更新区间覆盖，我们不立即更新其所有子节点，
// 而是将更新值存储在懒标记中，待需要访问子节点时再下传（pushDown）。
long long add[MAXN << 2];

// --- 线段树辅助函数 ---

/**
 * @brief 向上更新父节点的值。
 * @param i 当前父节点的索引。
 *
 * 当子节点（i<<1 和 i<<1|1）的值发生变化后，父节点的值需要根据子节点的值重新计算。
 * 这里是求和线段树，所以父节点的值是其左右子节点值的和。
 */
void up(int i) {
    sum[i] = sum[i << 1] + sum[i << 1 | 1];
}

/**
 * @brief 向下传递懒标记（Lazy Propagation）。
 * @param i 当前带有懒标记的节点索引。
 * @param ln 左子节点代表区间的长度。
 * @param rn 右子节点代表区间的长度。
 *
 * 如果当前节点 i 存在懒标记（add[i] != 0），则将其懒标记的值下传给左右子节点。
 * 懒标记的值会加到子节点的懒标记上，并且更新子节点对应的区间和（因为区间增加了 add[i] * 区间长度）。
 * 下传后，当前节点的懒标记清零。
 */
void down(int i, int ln, int rn) {
    if (add[i]) { // 如果当前节点有懒标记
        // 将懒标记的值传递给左子节点
        add[i << 1] += add[i];
        sum[i << 1] += add[i] * ln; // 更新左子节点的和：增加量 * 区间长度

        // 将懒标记的值传递给右子节点
        add[i << 1 | 1] += add[i];
        sum[i << 1 | 1] += add[i] * rn; // 更新右子节点的和：增加量 * 区间长度

        add[i] = 0; // 清除当前节点的懒标记，表示已经下传完毕
    }
}

/**
 * @brief 构建线段树。
 * @param l 当前节点代表区间的左边界。
 * @param r 当前节点代表区间的右边界。
 * @param i 当前节点的索引。
 *
 * 这是一个递归函数，用于从底向上构建线段树。
 * 叶子节点（l == r）直接赋值为对应的差分数组元素。
 * 非叶子节点通过递归构建左右子树，然后调用 up 函数更新自己的值。
 * 同时初始化所有节点的懒标记为0。
 */
void build(int l, int r, int i) {
    if (l == r) { // 如果是叶子节点
        sum[i] = diff[l]; // 叶子节点存储差分数组对应位置的值
    } else { // 如果是非叶子节点
        int mid = (l + r) >> 1; // 计算中间点
        build(l, mid, i << 1);        // 递归构建左子树
        build(mid + 1, r, i << 1 | 1); // 递归构建右子树
        up(i); // 更新当前节点的值
    }
    add[i] = 0; // 初始化懒标记为0
}

/**
 * @brief 对线段树进行区间增加操作。
 * @param jobl 操作区间的左边界。
 * @param jobr 操作区间的右边界。
 * @param jobv 要增加的值。
 * @param l 当前节点代表区间的左边界。
 * @param r 当前节点代表区间的右边界。
 * @param i 当前节点的索引。
 *
 * 这是一个递归函数，用于在线段树上对指定区间 [jobl, jobr] 加上 jobv。
 * 它利用懒标记进行高效的区间更新。
 */
void addVal(int jobl, int jobr, long long jobv, int l, int r, int i) {
    // 如果当前节点代表的区间 [l, r] 完全包含在操作区间 [jobl, jobr] 内
    if (jobl <= l && r <= jobr) {
        add[i] += jobv; // 直接更新当前节点的懒标记
        sum[i] += jobv * (r - l + 1); // 更新当前节点的和（增加量 * 区间长度）
    } else { // 否则，当前区间与操作区间有交叠，需要向下递归
        int mid = (l + r) >> 1; // 计算中间点
        // 在向下递归之前，需要先下传当前节点的懒标记，确保子节点是最新的
        down(i, mid - l + 1, r - mid);

        // 如果操作区间与左子树有交叠，则递归更新左子树
        if (jobl <= mid) {
            addVal(jobl, jobr, jobv, l, mid, i << 1);
        }
        // 如果操作区间与右子树有交叠，则递归更新右子树
        if (jobr > mid) {
            addVal(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
        }
        up(i); // 递归返回后，更新当前节点的值（根据其子节点）
    }
}

/**
 * @brief 对线段树进行区间查询操作（求和）。
 * @param jobl 查询区间的左边界。
 * @param jobr 查询区间的右边界。
 * @param l 当前节点代表区间的左边界。
 * @param r 当前节点代表区间的右边界。
 * @param i 当前节点的索引。
 * @return 查询区间内的和。
 *
 * 这是一个递归函数，用于在线段树上查询指定区间 [jobl, jobr] 内所有差分值的和。
 * 查询时同样需要处理懒标记。
 */
long long query(int jobl, int jobr, int l, int r, int i) {
    // 如果当前节点代表的区间 [l, r] 完全包含在查询区间 [jobl, jobr] 内
    if (jobl <= l && r <= jobr) {
        return sum[i]; // 直接返回当前节点的和
    }
    int mid = (l + r) >> 1; // 计算中间点
    // 在向下递归之前，需要先下传当前节点的懒标记
    down(i, mid - l + 1, r - mid);
    long long ans = 0; // 初始化查询结果

    // 如果查询区间与左子树有交叠，则递归查询左子树
    if (jobl <= mid) {
        ans += query(jobl, jobr, l, mid, i << 1);
    }
    // 如果查询区间与右子树有交叠，则递归查询右子树
    if (jobr > mid) {
        ans += query(jobl, jobr, mid + 1, r, i << 1 | 1);
    }
    return ans; // 返回累加的查询结果
}

// --- 主函数 ---

int main() {
    int n, m;
    scanf("%d%d", &n, &m); // 读取序列长度n和操作次数m

    // 构建初始差分数组。
    // 假设原数组为 A，差分数组 D 满足 D[i] = A[i] - A[i-1] (A[0] = 0)。
    // 那么 A[p] = D[1] + D[2] + ... + D[p]，即 A[p] 是差分数组的前缀和。
    int pre = 0, cur; // pre用于存储前一个元素的值，cur用于存储当前元素的值
    for (int i = 1; i <= n; i++) {
        scanf("%d", &cur);      // 读取当前元素的值
        diff[i] = cur - pre;     // 计算 diff[i] = A[i] - A[i-1]
        pre = cur;               // 更新 pre 为当前值，用于下一次循环
    }

    // 使用构建好的差分数组初始化线段树。
    // 线段树维护的是差分数组的区间和，通过查询差分数组的前缀和，可以得到原数组的单点值。
    build(1, n, 1);

    int op, l, r, p;    // op: 操作类型, l, r: 操作区间, p: 查询点
    long long k, d;     // k: 等差数列首项, d: 等差数列公差

    // 处理 m 次操作
    while (m--) {
        scanf("%d", &op); // 读取操作类型
        if (op == 1) { // 类型1操作：对原数组进行等差数列区间更新
            scanf("%d%d%lld%lld", &l, &r, &k, &d);

            // 核心思路：将对原数组 A 的等差数列区间更新转化为对差分数组 D 的点更新/区间更新。
            // 假设我们要对 A[l...r] 加上一个等差数列： k, k+d, k+2d, ..., k+(r-l)d
            // 这意味着：
            // A[l] 变为 A[l] + k
            // A[l+1] 变为 A[l+1] + (k+d)
            // ...
            // A[r] 变为 A[r] + (k+(r-l)d)

            // 考虑差分数组 D 的变化：D[i] = A[i] - A[i-1]
            // 1. 对于 D[l]：
            //   D[l]_new = A[l]_new - A[l-1]_new
            //   由于 A[l-1] 不受影响，A[l] 增加了 k，所以 D[l] 增加了 k。
            addVal(l, l, k, 1, n, 1); // 在差分数组的 l 位置增加 k

            // 2. 对于 D[l+1] 到 D[r]：
            //   D[i]_new = A[i]_new - A[i-1]_new
            //   A[i]_new = A[i] + (k + (i-l)d)
            //   A[i-1]_new = A[i-1] + (k + (i-1-l)d)
            //   D[i]_new = (A[i] + k + (i-l)d) - (A[i-1] + k + (i-1-l)d)
            //   D[i]_new = (A[i] - A[i-1]) + ((i-l)d - (i-1-l)d)
            //   D[i]_new = D[i] + d
            // 所以，从 l+1 到 r 的差分数组元素都增加了公差 d。
            if (l + 1 <= r) { // 确保区间有效
                addVal(l + 1, r, d, 1, n, 1); // 在差分数组的 [l+1, r] 区间增加 d
            }

            // 3. 对于 D[r+1]：
            //   D[r+1]_new = A[r+1]_new - A[r]_new
            //   A[r+1] 不受影响。A[r] 增加了 `k + (r-l)d`。
            //   所以 D[r+1] 会减少 `k + (r-l)d`。
            //   计算等差数列在 r 位置的末项值
            long long e = k + d * (r - l);
            if (r < n) { // 确保 r+1 位置存在
                addVal(r + 1, r + 1, -e, 1, n, 1); // 在差分数组的 r+1 位置减少末项值 e
            }
            // 为什么是-e？因为 D[r+1] = A[r+1] - A[r]。
            // A[r] 增加了 e，而 A[r+1] 不变，为了抵消 A[r] 增加对 D[r+1] 的影响，
            // 需要在 D[r+1] 上减去 e。这样，对于所有 i > r 的元素 A[i]，
            // 它们的差分值 D[i] (即 A[i]-A[i-1]) 都将恢复到只受 A[i-1] 影响前的状态，
            // 因为 A[i-1] 及以前的累积影响在这里被“归零”了。
            // 简单来说，这次更新将等差数列的影响“截断”在r的位置。
        } else { // 类型2操作：查询原数组单点值
            scanf("%d", &p); // 读取查询点p
            // 查询原数组 A[p] 的值，等价于查询差分数组 D[1] 到 D[p] 的和。
            // 这是差分数组的性质：A[p] = sum(D[1...p])
            printf("%lld\n", query(1, p, 1, n, 1));
        }
    }
    return 0; // 程序正常结束
}
