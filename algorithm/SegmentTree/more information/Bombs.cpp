#include <cstdio>       // 引入标准输入输出库，用于scanf和printf
#include <algorithm>    // 引入算法库，尽管在此代码中没有直接用到其特定函数，但通常是C++编程的好习惯

// 贪婪大陆
// 一共有n个格子，编号1~n，开始时格子上没有地雷，实现两种操作，一共调用m次
// 操作 1 l r : 在l~r范围的格子上放置一种新型地雷，每次地雷都是新款
// 操作 2 l r : 查询l~r范围的格子上一共放置过多少款不同的地雷
// 操作1并不是范围上替换地雷，而是范围上新增新型地雷，注意如下的例子
// 执行 1 3 6，表示3~6范围上新加一种地雷，假设地雷类型是A
// 执行 1 3 4，表示3~4范围上又新加一种地雷，和上次的地雷不同，假设地雷类型是B
// 格子3有两种地雷(A、B)、格子4有两种地雷(A、B)、格子5有一种地雷(A)、格子6有一种地雷(A)
// 执行 2 4 5，返回2；执行 2 5 6，会返回1
// 测试链接 : https://www.luogu.com.cn/problem/P2184

using namespace std;    // 使用标准命名空间，避免每次都写std::前缀

// 定义一个常量，表示原始数据（地雷可能放置的位置）的最大索引值
// MAXN 通常是问题的范围上限，这里是100000。
// 线段树需要大约 4 * N 的空间来存储所有节点，所以这里是 MAXN << 2 (即 MAXN * 4)。
const int MAXN = 100001;

// bombStarts 数组：线段树，用于存储每个位置上“地雷起始点”的数量。
// bombStarts[i] 存储以节点 i 为根的线段树区间内，所有地雷起始点的总数。
int bombStarts[MAXN << 2];

// bombEnds 数组：线段树，用于存储每个位置上“地雷结束点”的数量。
// bombEnds[i] 存储以节点 i 为根的线段树区间内，所有地雷结束点的总数。
// 我们需要两个独立的线段树来分别维护起始点和结束点的信息。
int bombEnds[MAXN << 2];

// --- 辅助函数 ---

// up 函数：向上更新节点信息
// 当子节点（i << 1 和 i << 1 | 1）的信息发生变化后，需要更新它们的父节点 i 的信息。
// 对于本题，父节点的地雷起始点数等于其左右子节点起始点数之和。
// 同样，父节点的地雷结束点数等于其左右子节点结束点数之和。
void up(int i) {
    bombStarts[i] = bombStarts[i << 1] + bombStarts[i << 1 | 1]; // 更新当前节点的起始点总数
    bombEnds[i] = bombEnds[i << 1] + bombEnds[i << 1 | 1];       // 更新当前节点的结束点总数
}

// build 函数：构建线段树（初始化操作）
// l, r: 当前节点 i 所代表的区间范围 [l, r]
// i: 当前线段树节点的索引
// 这是一个递归过程，从根节点开始，逐步向下构建树，并将所有节点的计数初始化为0。
void build(int l, int r, int i) {
    bombStarts[i] = 0; // 初始化当前节点的地雷起始点数为0
    bombEnds[i] = 0;   // 初始化当前节点的地雷结束点数为0
    if (l != r) {      // 如果不是叶子节点（区间不止一个元素）
        int mid = (l + r) >> 1;     // 计算中间点
        build(l, mid, i << 1);        // 递归构建左子树
        build(mid + 1, r, i << 1 | 1); // 递归构建右子树
        // 注意：这里不需要调用up(i)，因为子节点都是0，父节点自然也是0。
        // up(i) 主要用于在修改操作后，将子节点的变化向上汇报。
    }
}

// add 函数：增加地雷标记（点修改操作）
// jobt: 操作类型，0表示增加起始点，1表示增加结束点。
// jobi: 需要增加标记的具体位置（索引）。
// l, r: 当前节点 i 所代表的区间范围 [l, r]
// i: 当前线段树节点的索引
// 这个函数会在指定位置 jobi 增加一个起始点或结束点标记。
void add(int jobt, int jobi, int l, int r, int i) {
    if (l == r) { // 如果是叶子节点（找到了目标位置 jobi）
        if (jobt == 0) bombStarts[i]++; // 如果是起始点标记，增加 bombStarts 的计数
        else bombEnds[i]++;             // 如果是结束点标记，增加 bombEnds 的计数
    } else { // 如果是非叶子节点，继续向下查找目标位置
        int mid = (l + r) >> 1; // 计算中间点
        if (jobi <= mid) {      // 如果目标位置在左子区间
            add(jobt, jobi, l, mid, i << 1); // 递归到左子树
        } else {                // 如果目标位置在右子区间
            add(jobt, jobi, mid + 1, r, i << 1 | 1); // 递归到右子树
        }
        up(i); // 递归返回后，向上更新当前节点的信息，累加子节点的计数
    }
}

// query 函数：查询区间统计值（区间求和操作）
// jobt: 查询类型，0表示查询起始点总数，1表示查询结束点总数。
// jobl, jobr: 需要查询的区间范围 [jobl, jobr]
// l, r: 当前节点 i 所代表的区间范围 [l, r]
// i: 当前线段树节点的索引
// 这个函数会返回指定区间 [jobl, jobr] 内，起始点或结束点的总数量。
int query(int jobt, int jobl, int jobr, int l, int r, int i) {
    // 情况1: 当前节点区间 [l, r] 完全包含在目标查询区间 [jobl, jobr] 内
    if (jobl <= l && r <= jobr) {
        // 根据查询类型返回相应线段树的计数
        return jobt == 0 ? bombStarts[i] : bombEnds[i];
    } else { // 情况2: 当前节点区间与目标查询区间有交集，但不是完全包含
        int mid = (l + r) >> 1; // 计算中间点
        int ans = 0;           // 初始化查询结果

        // 递归查询左子树：如果目标区间与左子树有交集
        if (jobl <= mid) {
            ans += query(jobt, jobl, jobr, l, mid, i << 1);
        }
        // 递归查询右子树：如果目标区间与右子树有交集
        if (jobr > mid) {
            ans += query(jobt, jobl, jobr, mid + 1, r, i << 1 | 1);
        }
        return ans; // 返回累加的查询结果
    }
}

// --- 主函数 ---

int main() {
    int n, m; // n: 地雷可能放置的最大位置（范围），m: 操作的总次数
    scanf("%d %d", &n, &m); // 读取 n 和 m

    build(1, n, 1); // 构建并初始化线段树，位置编号从1到n，根节点索引为1

    // 循环处理 m 次操作
    for (int i = 1, op, jobl, jobr; i <= m; i++) {
        scanf("%d %d %d", &op, &jobl, &jobr); // 读取操作类型 op 和操作区间 [jobl, jobr]
        if (op == 1) { // 如果操作类型是 1，表示添加一个地雷 (区间 [jobl, jobr])
            add(0, jobl, 1, n, 1); // 在 jobl 位置增加一个地雷起始标记（类型0）
            add(1, jobr, 1, n, 1); // 在 jobr 位置增加一个地雷结束标记（类型1）
        } else { // 如果操作类型是 2，表示查询有多少地雷与区间 [jobl, jobr] 重叠
            // s: 查询从位置 1 到 jobr 为止，有多少个地雷已经“开始”了。
            // 也就是统计所有 S <= jobr 的地雷数量。
            int s = query(0, 1, jobr, 1, n, 1);

            // e: 查询从位置 1 到 jobl-1 为止，有多少个地雷已经“结束”了。
            // 也就是统计所有 E < jobl 的地雷数量。
            // 特别注意：如果 jobl 为 1，则 jobl-1 为 0，表示没有地雷在其之前结束，所以直接设为 0。
            int e = (jobl == 1) ? 0 : query(1, 1, jobl - 1, 1, n, 1);

            // 核心思想：
            // 重叠地雷数 = (所有在 jobr 之前或在 jobr 处开始的地雷总数)
            //              - (所有在 jobl 之前结束的地雷总数)
            // 形象地说，我们筛选出所有“可能”与 [jobl, jobr] 重叠的地雷 (S <= jobr)，
            // 然后从中剔除那些“肯定不重叠”的（E < jobl）。
            // 剩下的就是那些 S <= jobr 且 E >= jobl 的地雷，这正是重叠的条件！
            printf("%d\n", s - e);
        }
    }
    return 0; // 程序正常结束
}

