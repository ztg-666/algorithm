#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,int> pii;

const int N = 305, mod = 1e9 + 7;

int n, q;            // n：志愿者人数；q：方案数量
int c[3];            // c[0], c[1], c[2]：字符串中已固定的 a/b/c 的数量
string a;            // 位置 1..n 的字符串，字符为 'a','b','c' 或 '?'

// f[i][j][k][t]：前缀长度为 i+j+k 的合法排列数，
// 其中 'a' 用了 i 个，'b' 用了 j 个，'c' 用了 k 个，且最后一个字符是 t（0=a,1=b,2=c）。
// 注意：相邻不可相同，且若当前位置在原串中已固定，则不允许与固定字符矛盾。
ll f[N][N][N][3];

// s[i][j][k]：将所有长度为 n 的方案中，计数到三维前缀 (≤i, ≤j, ≤k) 的总数
// 也就是 sum_{i'≤i, j'≤j, k'≤k, i'+j'+k'=n}  ways(i',j',k')
// 便于回答“每种服装最多做 i/j/k 套”这类不超过限制的询问（通过 3D 前缀和 + 容斥实现）。
ll s[N][N][N];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> q >> a;
    a = " " + a; // 让下标从 1 开始，方便与题意一致

    // 统计原串中已固定的 a/b/c 数量
    for (int i = 1; i <= n; ++i)
        if (a[i] != '?') ++c[a[i] - 'a'];

    // 初始化长度为 1 的三种结尾
    // 此处先不考虑 a[1] 的固定限制；我们在后面的循环里会在每个位置统一“清零”不合法的结尾状态。
    f[1][0][0][0] = 1; // 只放一个 'a'
    f[0][1][0][1] = 1; // 只放一个 'b'
    f[0][0][1][2] = 1; // 只放一个 'c'

    // 枚举 i,j,k，表示当前前缀长度 p = i+j+k
    // 当 p>0 时，检查位置 p 的固定字符，先把与其冲突的结尾清零；再从 p 转移到 p+1
    for (int i = 0; i <= n; ++i)
        for (int j = 0; i + j <= n; ++j)
            for (int k = 0; i + j + k <= n; ++k) if (i + j + k > 0) {
                int p = i + j + k; // 当前前缀的长度，也对应原串的位置

                // 若 a[p] 是固定字符，则将不以该字符结尾的状态清零
                // 这样可以保证“前缀的最后一个字符必须等于 a[p]（若固定）”
                if (a[p] == 'a') f[i][j][k][1] = f[i][j][k][2] = 0; // 只能以 'a' 结尾
                if (a[p] == 'b') f[i][j][k][0] = f[i][j][k][2] = 0; // 只能以 'b' 结尾
                if (a[p] == 'c') f[i][j][k][0] = f[i][j][k][1] = 0; // 只能以 'c' 结尾

                // 向下一位转移（如果还没到长度 n）
                // 相邻不可相同：因此下一个字符与当前结尾 t 必须不同。
                // 于是 f[..][..][..][0]（以 a 结尾）的下一位可转到 'b' 或 'c'；依此类推。
                if (p < n) {
                    // 下一位放 'a'：增加 i 的数量，并且上一位结尾不能是 'a'（即从 [1] 或 [2] 来）
                    (f[i + 1][j][k][0] += f[i][j][k][1] + f[i][j][k][2]) %= mod;
                    // 下一位放 'b'：增加 j
                    (f[i][j + 1][k][1] += f[i][j][k][0] + f[i][j][k][2]) %= mod;
                    // 下一位放 'c'：增加 k
                    (f[i][j][k + 1][2] += f[i][j][k][0] + f[i][j][k][1]) %= mod;
                }
            }

    // 计算三维前缀和数组 s
    // 首先：当 i+j+k==n（恰好用完 n 个字符）时，将三种结尾汇总到 s[i][j][k] 里
    // 随后对 s 做 3D 前缀和（带容斥）以支持“≤”型的限制查询。
    for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= n; ++j)
            for (int k = 0; k <= n; ++k) {
                if (i + j + k == n) {
                    s[i][j][k] = (f[i][j][k][0] + f[i][j][k][1] + f[i][j][k][2]) % mod;
                }

                // 3D 前缀和：s 变为对 (≤i, ≤j, ≤k) 的累加和
                if (i > 0) s[i][j][k] += s[i - 1][j][k];
                if (j > 0) s[i][j][k] += s[i][j - 1][k];
                if (k > 0) s[i][j][k] += s[i][j][k - 1];

                if (i > 0 && j > 0) s[i][j][k] -= s[i - 1][j - 1][k];
                if (i > 0 && k > 0) s[i][j][k] -= s[i - 1][j][k - 1];
                if (j > 0 && k > 0) s[i][j][k] -= s[i][j - 1][k - 1];

                if (i > 0 && j > 0 && k > 0) s[i][j][k] += s[i - 1][j - 1][k - 1];

                s[i][j][k] = (s[i][j][k] % mod + mod) % mod; // 取模与防负
            }

    // 处理每个定制方案 (x,y,z)
    // 原串中已固定的 a/b/c 数量为 c[0/1/2]，新做的最多 x/y/z 套
    // 则总可用上限分别是 x+c[0], y+c[1], z+c[2]，并且每种最多不能超过 n
    // 因为 s 做的是“≤”型的三维前缀和，所以直接查询 s[x'][y'][z'] 即为答案
    // （它包含了所有恰好 n 个位置的方案，且三类数量分别 ≤ 上限）
    while (q--) {
        int x, y, z;
        cin >> x >> y >> z;

        int X = min(x + c[0], n);
        int Y = min(y + c[1], n);
        int Z = min(z + c[2], n);

        cout << s[X][Y][Z] << '\n';
    }
}
