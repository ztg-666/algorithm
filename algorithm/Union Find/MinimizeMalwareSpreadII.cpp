#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

const int MAXN = 301;
bool virus[MAXN];    // 标记节点是否为恶意软件源头
int cnts[MAXN];      // 记录每个源头节点能拯救的节点数
int infect[MAXN];    // 记录集合的感染源头信息
int father[MAXN];    // 并查集的父节点数组
int _size[MAXN];     // 记录集合的大小

// 初始化并查集和相关数组
void build(int n, vector<int>& initial) {
    for (int i = 0; i < n; ++i) {
        virus[i] = false;  // 初始化所有节点为非恶意软件源头
        cnts[i] = 0;       // 初始化每个源头节点能拯救的节点数为 0
        infect[i] = -1;    // 初始化集合的感染源头信息为 -1（未发现源头）
        _size[i] = 1;      // 初始化每个集合的大小为 1
        father[i] = i;     // 初始化每个节点的父节点为其自身
    }
    for (int i : initial) {
        virus[i] = true;   // 标记初始感染源节点
    }
}

// 路径压缩查找
int find(int x) {
    if (x != father[x]) {
        father[x] = find(father[x]); // 路径压缩
    }
    return father[x]; // 返回根节点
}

// 合并两个集合
void unionSet(int x, int y) {
    int fx = find(x);
    int fy = find(y);
    if (fx != fy) {
        father[fx] = fy; // 合并集合
        _size[fy] += _size[fx]; // 更新集合大小
    }
}

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    build(n, initial); // 初始化数据结构

    // 第一步：合并所有普通节点
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (graph[i][j] && !virus[i] && !virus[j]) {
                unionSet(i, j); // 合并未被感染的节点
            }
        }
    }

    // 第二步：标记各集合的感染源头
    for (int sick : initial) {
        for (int neighbor = 0; neighbor < n; ++neighbor) {
            if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor]) {
                int fn = find(neighbor);
                if (infect[fn] == -1) {
                    infect[fn] = sick; // 标记集合的感染源头
                } else if (infect[fn] != -2 && infect[fn] != sick) {
                    infect[fn] = -2; // 标记为多源头感染
                }
            }
        }
    }

    // 第三步：统计每个源头能拯救的节点数
    for (int i = 0; i < n; ++i) {
        if (i == find(i) && infect[i] >= 0) {
            cnts[infect[i]] += _size[i]; // 累加集合大小到对应的感染源头
        }
    }

    // 第四步：选择最优解
    sort(initial.begin(), initial.end());
    int ans = initial[0];
    int maxCnt = cnts[ans];
    for (int node : initial) {
        if (cnts[node] > maxCnt) {
            maxCnt = cnts[node];
            ans = node; // 选择能拯救最多节点的感染源
        }
    }
    return ans;
}
// 尽量减少恶意软件的传播 II
// 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示
// 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
// 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
// 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
// 我们可以从 initial 中删除一个节点，
// 并完全移除该节点以及从该节点到任何其他节点的任何连接。
// 请返回移除后能够使 M(initial) 最小化的节点。
// 如果有多个节点满足条件，返回索引 最小的节点 。
// initial 中每个整数都不同
// 测试链接 : https://leetcode.cn/problems/minimize-malware-spread-ii/
int main() {
    vector<vector<int>> graph1 = {
        {1,1,0,0},
        {1,1,0,0},
        {0,0,1,1},
        {0,0,1,1}
    };
    vector<int> initial1 = {0, 3};
    cout << minMalwareSpread(graph1, initial1) << endl; // 应返回 0

    vector<vector<int>> graph2 = {
        {1,0,0,0},
        {0,1,0,0},
        {0,0,1,1},
        {0,0,1,1}
    };
    vector<int> initial2 = {3, 1};
    cout << minMalwareSpread(graph2, initial2) << endl; // 应返回 3

    return 0;
}
