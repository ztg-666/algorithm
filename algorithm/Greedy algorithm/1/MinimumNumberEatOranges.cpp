#include <unordered_map>
#include <algorithm>
using namespace std;
// 吃掉N个橘子的最少天数
// 厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子
// 1）吃掉一个橘子
// 2) 如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子
// 3) 如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子
// 每天你只能从以上 3 种方案中选择一种方案
// 请你返回吃掉所有 n 个橘子的最少天数
// 测试链接 : https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/
class Solution {
public:
    // 记忆化存储表：key-剩余橘子数，value-最小天数
    unordered_map<int, int> dp;

    int minDays(int n) {
        // 基础情况处理
        if (n <= 1) return n; // 0或1个橘子只需0或1天

        // 查询已计算过的结果
        if (dp.count(n)) return dp[n];

        /******************************************************************
         * 核心策略分析：
         * 1. 吃法2的前提：将橘子数吃到能被2整除所需的天数 + 1天吃半 + 后续处理
         *    - n%2 : 需要先吃掉n%2个橘子才能达到2的倍数
         *    - +1  : 执行吃半操作的天数
         *    - n/2 : 吃半后剩余的橘子数
         * 2. 吃法3的前提：将橘子数吃到能被3整除所需的天数 + 1天吃三分之二 + 后续处理
         *    - n%3 : 需要先吃掉n%3个橘子才能达到3的倍数
         *    - +1  : 执行吃三分之二操作的天数
         *    - n/3 : 吃三分之二后剩余的橘子数
         * 注意：此处隐含了吃法1的策略，通过n%2和n%3的计算自然包含单吃的步骤
         ******************************************************************/
        int eat2 = (n % 2) + 1 + minDays(n / 2); // 选择吃半策略的总天数
        int eat3 = (n % 3) + 1 + minDays(n / 3); // 选择吃三分之二策略的总天数

        // 取两种策略的最小值
        int ans = min(eat2, eat3);

        // 存储计算结果
        dp[n] = ans;
        return ans;
    }
};
