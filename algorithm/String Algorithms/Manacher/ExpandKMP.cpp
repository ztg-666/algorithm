#include <iostream> // 引入标准输入输出库，用于cin和cout操作
#include <string>   // 引入字符串库，用于处理std::string类型
#include <vector>   // 引入动态数组库，用于使用std::vector

// 扩展KMP模版，又称Z算法或Z函数
// 给定两个字符串a、b，求出两个数组
// b与b每一个后缀串的最长公共前缀长度，z数组
// b与a每一个后缀串的最长公共前缀长度，e数组
// 计算出要求的两个数组后，输出这两个数组的权值即可
// 对于一个数组x，i位置的权值定义为 : (i * (x[i] + 1))
// 数组权值为所有位置权值的异或和
// 测试链接 : https://www.luogu.com.cn/problem/P5410

using namespace std; // 使用std命名空间，避免每次都写std::

// 定义一个最大常量，通常用于数组大小。
// 20000001 (2*10^7 + 1) 是一个相当大的值，确保能处理长度高达2千万的字符串。
// 这反映了对处理大规模数据的准备。
const int MAXN = 20000001;

// 全局声明Z数组。
// z[i] 用于存储字符串b的后缀b[i...]与b自身的最长公共前缀的长度。
// 这是Z算法的核心输出。
vector<int> z(MAXN);

// 全局声明E数组。
// e[i] 用于存储字符串a的后缀a[i...]与字符串b的最长公共前缀的长度。
// 这是本代码中实现的一种“扩展Z算法”的结果。
vector<int> e(MAXN);

// --- 函数定义开始 ---

// Z算法核心实现函数：计算字符串s的Z数组
// 参数：
//   s: 待计算Z数组的字符串。在本例中，s是字符串b。
//   n: 字符串s的长度。
void zArray(string s, int n) {
    // 根据Z算法的定义，Z[0] 总是等于字符串的长度，
    // 因为字符串自身与自身的最长公共前缀就是整个字符串。
    z[0] = n;

    // 遍历字符串的每一个字符，从下标1开始计算Z值。
    // c (center) 和 r (right) 是Z算法的关键优化变量，它们定义了一个“Z-box” [c, r]。
    // Z-box 是一个以c为起始，r为结束的区间，表示 s[c...r-1] 是 s 的一个前缀。
    // 并且我们已经计算出 s[c...r-1] 与 s[0...r-1-c] 是完全匹配的。
    for (int i = 1, c = 0, r = 0, len; i < n; i++) {
        // 如果当前处理的下标 i 在已知的最大Z-box [c, r) 内部：
        // len 的初始值可以利用 Z[i-c] 的信息。
        // min(r - i, z[i - c]) 的含义是：
        // r - i: 是当前Z-box从 i 开始到 r 结束的剩余长度。
        // z[i - c]: 是与 s[i] 在 Z-box 中对称位置 i-c 对应的 Z 值。
        // 我们取这两者的最小值，因为我们知道 s[c...r-1] 和 s[0...r-1-c] 匹配，
        // 所以 s[i...r-1] 和 s[i-c...r-1-c] 也是匹配的。
        // 那么，s[i...] 与 s 的最长公共前缀至少是 min(剩余长度, z[i-c])。
        len = (r > i) ? min(r - i, z[i - c]) : 0;

        // 如果 i 不在任何已知的Z-box内（r <= i），或者利用Z-box信息得到的 len 已经到了Z-box边界，
        // 我们需要通过暴力匹配来扩展 len。
        // 这个while循环会一直比较 s[i + len] 和 s[len] 是否相等。
        // s[i + len] 是当前后缀的下一个字符。
        // s[len] 是字符串s前缀的下一个字符。
        // 只要它们相等，就说明公共前缀还可以继续延伸。
        while (i + len < n && s[i + len] == s[len]) {
            len++; // 扩展公共前缀长度
        }

        // 更新最大的Z-box：
        // 如果当前 Z-value (len) 使得 i + len 超过了当前的 r，
        // 意味着我们找到了一个新的、更大的匹配区域，
        // 那么我们就更新 Z-box 的中心 c 为 i，右边界 r 为 i + len。
        if (i + len > r) {
            r = i + len;
            c = i;
        }

        // 将计算出的最长公共前缀长度存储到Z数组中。
        z[i] = len;
    }
}

// 扩展Z算法函数：计算字符串a的每个后缀与字符串b的最长公共前缀（LCP）
// 参数：
//   a: 主字符串，待检查其后缀。
//   b: 模式字符串，用于比较。
//   n: 字符串a的长度。
//   m: 字符串b的长度。
void eArray(string a, string b, int n, int m) {
    // 遍历字符串a的每一个字符，从下标0开始计算E值。
    // c (center) 和 r (right) 在这里也用于优化，
    // 它们表示的是当前已知的、a的某个后缀与b的最长公共前缀形成的Z-box。
    // 具体来说，r 是 a[c...r-1] 与 b 的一个匹配段的右边界。
    for (int i = 0, c = 0, r = 0, len; i < n; i++) {
        // 这里的逻辑与 zArray 类似，但 Z 值是针对字符串 b 自身的。
        // 如果当前处理的下标 i 在已知的Z-box [c, r) 内部：
        // len 的初始值利用了 Z[i-c] 的信息，这里的 Z[i-c] 指的是 b 自身的 Z 数组值。
        // 它的含义是：a[i...] 与 b[0...] 的最长公共前缀，至少可以利用 b[i-c...] 与 b[0...] 的匹配长度。
        // 并且这个长度不能超过当前Z-box的剩余长度 (r - i)。
        len = (r > i) ? min(r - i, z[i - c]) : 0;

        // 暴力匹配阶段：
        // 只要 a[i + len] 等于 b[len]，并且没有超出字符串 a 或 b 的边界，
        // 就继续延伸公共前缀的长度。
        // i + len < n: 确保没有超出字符串a的边界。
        // len < m: 确保没有超出字符串b的边界。
        while (i + len < n && len < m && a[i + len] == b[len]) {
            len++; // 扩展公共前缀长度
        }

        // 更新最大的Z-box：
        // 如果当前匹配长度 len 使得 i + len 超过了当前的 r，
        // 说明我们找到了一个新的、更大的 a 的后缀与 b 的前缀匹配区域。
        // 更新 Z-box 的中心 c 为 i，右边界 r 为 i + len。
        if (i + len > r) {
            r = i + len;
            c = i;
        }

        // 将计算出的最长公共前缀长度存储到E数组中。
        e[i] = len;
    }
}

// 计算数组权值：所有位置 (i+1) * (arr[i]+1) 的异或和
// 参数：
//   arr: 待计算权值的整型向量（Z数组或E数组）。
//   n: 向量的长度。
// 返回值：计算得到的异或和。
long long eor(vector<int>& arr, int n) {
    long long ans = 0; // 初始化异或和为0
    // 遍历数组的每一个元素
    for (int i = 0; i < n; i++) {
        // 根据题目要求，计算当前位置的权值：(下标 i + 1) 乘以 (数组值 arr[i] + 1)。
        // 注意这里将结果强制转换为 long long，以防止溢出，
        // 因为 (i+1) * (arr[i]+1) 的值可能非常大，超过int的范围。
        // 例如，i 可以达到 2*10^7，arr[i] 也可以达到 2*10^7，它们的乘积会是 4*10^14，远超 int 范围。
        long long currentValue = (long long)(i + 1) * (arr[i] + 1);
        // 将当前位置的权值与总的异或和进行异或操作。
        // 异或操作 (XOR) 是一种位运算，其特性是相同为0，不同为1。
        // 它的一个重要性质是 A ^ B ^ B = A，常用于加密、数据校验或查找唯一值等。
        ans ^= currentValue;
    }
    return ans; // 返回最终的异或和
}

// 主函数：程序执行的入口
int main() {
    string a, b; // 声明两个字符串变量a和b
    cin >> a >> b; // 从标准输入读取字符串a和b

    int n = a.size(); // 获取字符串a的长度
    int m = b.size(); // 获取字符串b的长度

    // 首先调用zArray函数计算字符串b的Z数组。
    // Z数组是E数组计算的优化基础，因为它包含了b自身前缀匹配的信息。
    zArray(b, m);

    // 然后调用eArray函数计算字符串a与b的扩展Z数组（E数组）。
    // 这个函数会利用前面计算好的z数组进行优化。
    eArray(a, b, n, m);

    // 计算并输出Z数组的权值异或和。
    // 这对应题目中对Z数组的特定要求。
    cout << eor(z, m) << endl;

    // 计算并输出E数组的权值异或和。
    // 这对应题目中对E数组的特定要求。
    cout << eor(e, n) << endl;

    return 0; // 程序成功执行，返回0
}
