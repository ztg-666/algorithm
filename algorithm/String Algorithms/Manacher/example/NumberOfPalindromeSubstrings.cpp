#include <string>     // 包含字符串类，用于处理输入字符串
#include <algorithm>  // 包含算法函数，例如min函数，用于取两者最小值
#include <vector>     // 虽然此处使用了C风格数组，但通常也会包含vector，这里保留

// 回文子串数量
// 返回字符串s的回文子串数量
// 测试链接 : https://leetcode.cn/problems/palindromic-substrings/

using namespace std; // 使用标准命名空间，避免每次都写std::

// 定义最大原始字符串长度的上限。这里设置为1001，意味着原始字符串长度最多为1000。
// 因为 Manacher 算法会进行字符串预处理，处理后的字符串长度会变为 2 * len + 1。
// 所以 MAXN << 1 (等同于 MAXN * 2) 足够存储处理后的字符串及其回文半径数组。
const int MAXN = 1001;

// 全局字符数组，用于存储经过Manacher算法预处理后的字符串。
// 例如："aba" 会被处理成 "#a#b#a#"，存储在这个数组中。
// 大小 MAXN << 1 (2002) 足够存储长度最大为1000的原始字符串的处理结果。
char ss[MAXN << 1];

// 全局整数数组，用于存储每个位置的回文半径。
// p[i] 表示以 ss[i] 为中心的最长回文子串的“半径”（即从中心向一侧扩展的长度，包含中心本身）。
// 大小同样是 MAXN << 1。
int p[MAXN << 1];

// 全局变量，存储经过Manacher预处理后字符串的实际长度。
// 例如，如果原始字符串长度为 len，则处理后的长度 n = 2 * len + 1。
int n;

// 辅助函数：manacherss (Manacher String Preprocessor)
// 🔄 这个函数是 Manacher 算法的第一步：字符串预处理！
// 🎯 它的核心目标是将原始字符串 s 转换成一个新格式，
//    使得所有回文子串（无论是奇数长度还是偶数长度）在处理后的字符串中
//    都表现为奇数长度的回文，从而统一了算法处理逻辑，极大简化了问题。
// 💡 例如：原始字符串 "aba" -> 处理后 " #a#b#a# "
// 💡 例如：原始字符串 "abba" -> 处理后 " #a#b#b#a# "
void manacherss(const string& str) {
    // 计算处理后字符串的总长度。
    // 原始长度为 str.size()，处理后是 2 * str.size() + 1。
    n = str.size() * 2 + 1;

    // 遍历填充 ss 数组。
    // 使用一个内部计数器 j 来追踪原始字符串的字符。
    // `(i & 1) == 0` 是位运算技巧，用于判断 i 是否为偶数。
    // 如果 i 是偶数（0, 2, 4, ...），则在 ss[i] 处放置分隔符 '#'。
    // 如果 i 是奇数（1, 3, 5, ...），则在 ss[i] 处放置原始字符串的字符，并递增 j。
    for (int i = 0, j = 0; i < n; i++) {
        ss[i] = (i & 1) == 0 ? '#' : str[j++];
    }
}

// 核心 Manacher 算法实现
// 🧠 这个函数是 Manacher 算法的“大脑”！它遍历预处理后的字符串 ss，
//    计算并存储每个位置 i 的最长回文半径 p[i]。
void manacher(const string& str) {
    // 首先调用预处理函数，将原始字符串转换为 ss 数组并设置 n 的值。
    manacherss(str);

    // 初始化 Manacher 算法的关键变量：
    // i: 当前正在处理的中心位置在 ss 数组中的索引。
    // c: 当前“最右回文”的中心 (Center)。“最右回文”是指其右边界 r 最大的回文子串。
    // r: 当前“最右回文”的右边界 (Right boundary)。r = c + p[c]。
    // len: 临时变量，用于存储当前位置 i 的回文半径。
    for (int i = 0, c = 0, r = 0, len; i < n; i++) {
        // 💫 **利用对称性加速** (Manacher 算法的精髓之一！)
        //    如果当前位置 i 在“最右回文”的覆盖范围内 (即 i < r)，
        //    那么 i 关于 c 的对称点是 `2 * c - i` (我们称之为 `mirror_i`)。
        //    此时，p[i] 的初始值至少是 p[mirror_i] 和 `r - i` 中的较小值。
        //    `r - i` 表示 i 到当前最右回文右边界的距离，这是 i 能向右扩展的最大长度，
        //    因为它不能超过已经发现的最右回文的边界。
        //    如果 i >= r，说明 i 在当前“最右回文”的右边或正好在边界上，
        //    此时无法利用对称性，我们从最小的回文半径1开始（即自身就是一个回文，如 '#' 或 'a'）。
        len = r > i ? min(p[2 * c - i], r - i) : 1;

        // 4. **中心扩展法**：在利用对称性预估的基础上，尝试继续扩展回文。
        //    只要满足三个条件：
        //    a. `i + len` 不越界 (不超出 ss 的右边界 n)
        //    b. `i - len` 不越界 (不超出 ss 的左边界 0)
        //    c. `ss[i + len]` 和 `ss[i - len]` 字符相等 (满足回文条件)
        //    就继续增加 `len`。
        while (i + len < n && i - len >= 0 && ss[i + len] == ss[i - len]) {
            len++; // 回文半径扩展！
        }

        // 5. **更新“最右回文”的中心 c 和右边界 r**
        //    如果当前以 i 为中心的回文子串的右边界 `i + len` 超过了当前的 `r`，
        //    说明我们找到了一个新的、向右扩展更远的回文，那么就需要更新 `c` 和 `r`。
        if (i + len > r) {
            r = i + len; // 更新最右边界 r
            c = i;       // 更新最右回文的中心 c
        }

        // 6. **记录当前位置 i 的回文半径**
        p[i] = len;
    }
}

// 主函数：统计给定字符串中所有回文子串的数量
// 🎁 这是提供给外部调用的接口，简洁明了地返回最终的统计结果。
int countSubstrings(string s) {
    // 调用核心 Manacher 算法，计算并填充 p 数组。
    // p 数组中存储了每个字符（或分隔符）作为中心的回文半径。
    manacher(s);

    int ans = 0; // 初始化回文子串的总数量

    // 遍历 p 数组，统计所有回文子串的数量。
    // 🔑 核心洞察：对于 ss 中的每一个中心 i，其对应的回文半径 p[i]
    //    直接告诉了我们以该中心为核心，在原始字符串中能产生多少个回文子串。
    //    为什么是 p[i] / 2 呢？
    //    理解 p[i] 的含义：它表示以 ss[i] 为中心的最长回文的“半径”。
    //    在 ss 中，如果一个回文的半径是 L，那么它在原始字符串中对应的长度是 L-1。
    //    例如：
    //    - 如果 p[i] = 1 (如中心是 '#')，表示 `#` 本身，不对应原始字符串中的回文。1/2 = 0。✅
    //    - 如果 p[i] = 2 (如中心是 'a'，形成 `#a#`)，表示原始字符串中的 'a'。2/2 = 1。✅
    //    - 如果 p[i] = 3 (如中心是 '#'，形成 `#a#a#`)，表示原始字符串中的 "aa"。3/2 = 1。✅
    //    - 如果 p[i] = 4 (如中心是 'b'，形成 `#a#b#a#`)，表示原始字符串中的 "aba" 和 "b"。4/2 = 2。✅
    //    - 对于每个 `p[i]` 的值，它所代表的从 `ss[i]` 向外扩展的每一层，都对应着原始字符串中一个独特的、新的回文子串。
    //    - `p[i]` 的值 `L` 意味着从中心 `i` 向左右各扩展了 `L-1` 个位置。每向外扩展一个字符（即 `L` 增加 2），就多了一个回文子串。
    //    - 因此，`p[i] / 2` (整数除法) 正好可以计算出由 `ss[i]` 提供的、**不重复**的原始回文子串数量。
    for (int i = 0; i < n; i++) {
        ans += p[i] / 2; // 将当前中心贡献的回文数量累加到总数中
    }
    return ans; // 返回所有回文子串的总数量
}
