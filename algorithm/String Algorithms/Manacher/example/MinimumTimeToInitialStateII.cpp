#include<bits/stdc++.h> // 包含所有标准库头文件，这是一种便捷方式，但在大型项目中通常推荐按需包含特定头文件，以减少编译时间和依赖。

// 将单词恢复初始状态所需的最短时间II
// 给你一个下标从0开始的字符串word和一个整数k
// 在每一秒，必须执行以下操作
// 移除word的前k个字符
// 在word的末尾添加k个任意字符
// 添加的字符不必和移除的字符相同
// 返回将word恢复到初始状态所需的最短时间
// 该时间必须大于零
// 测试链接 : https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/

using namespace std; // 声明使用标准命名空间，这样就不必在标准库的类型和函数前加上 std:: 前缀。

/**
 * @brief Z 数组计算函数
 * * Z 数组 (Z-algorithm) 是字符串算法中一个非常强大的工具，
 * 它用于计算一个字符串 S 的 Z 数组。Z[i] 表示从索引 i 开始的后缀与字符串 S 的最长公共前缀的长度。
 * * 例如：
 * S = "ababa"
 * Z[0] = 5  (整个字符串与自身匹配)
 * Z[1] = 0  ("baba" 与 "ababa" 的最长公共前缀是 "")
 * Z[2] = 3  ("aba" 与 "ababa" 的最长公共前缀是 "aba")
 * Z[3] = 0  ("ba" 与 "ababa" 的最长公共前缀是 "")
 * Z[4] = 1  ("a" 与 "ababa" 的最长公共前缀是 "a")
 * * @param s 输入字符串
 * @param z 引用传递的 Z 数组，用于存储计算结果。它的长度应与字符串 s 的长度相同。
 */
void zArray(const string& s, vector<int>& z) {
    int n = s.size(); // 获取字符串的长度
    z[0] = n; // Z[0] 特殊处理：从索引 0 开始的后缀就是字符串本身，所以最长公共前缀的长度就是字符串的长度。

    // 遍历字符串的每个字符，从索引 1 开始计算 Z 值。
    // c (center): 当前 Z-box (Z 块) 的起始索引。Z-box 是一个区域 [c, r]，
    //             其中 s[c...r-1] 与 s[0...r-c-1] 完全匹配，且这个 Z-box 是所有已经计算过的 Z[k] 中，
    //             使得 k + Z[k] - 1 最大的那个。简单来说，它是目前发现的最右侧的匹配区域。
    // r (right): 当前 Z-box 的结束索引 + 1。即 Z-box 的范围是 [c, r-1]。
    for (int i = 1, c = 1, r = 1, len; i < n; i++) {
        // len 初始化：利用 Z-box 的特性来加速计算。
        // 如果当前索引 i 在 Z-box 内部 (即 i < r)，那么我们可以利用之前的计算结果。
        // Z[i - c] 已经计算了 s[i-c...] 和 s 的公共前缀长度。
        // 因为 s[c...r-1] == s[0...r-c-1]，所以 s[i...r-1] 也应该等于 s[i-c...r-c-1]。
        // 那么 s[i...] 与 s 的公共前缀至少是 min(r - i, z[i - c])。
        // r - i 是 i 到 Z-box 右边界的距离，我们需要确保不超过这个范围。
        // 如果 i 不在 Z-box 内部 (即 i >= r)，则 len 初始化为 0，从头开始匹配。
        len = (r > i) ? min(r - i, z[i - c]) : 0;

        // 暴力扩展匹配：在 Z-box 的加速基础上，继续向右扩展匹配长度。
        // 条件是：1. 扩展后的索引不能超出字符串范围 (i + len < n)。
        //         2. 当前字符 s[i + len] 必须与对应的模式字符 s[len] 相同。
        while (i + len < n && s[i + len] == s[len]) {
            len++; // 匹配成功，长度增加
        }

        // 更新 Z-box：如果当前的匹配 (i, i + len - 1) 超过了之前 Z-box 的右边界，
        // 就更新 c 和 r，因为我们找到了一个更右侧的 Z-box。
        if (i + len > r) {
            r = i + len; // 新的右边界是当前匹配的结束位置 + 1
            c = i;       // 新的 Z-box 的起始索引是当前索引 i
        }
        z[i] = len; // 将计算出的 Z 值存入 Z 数组
    }
}

/**
 * @brief 计算将字符串 word 恢复到初始状态所需的最小操作次数
 * * 每次操作，我们从字符串的开头移除 k 个字符，并将这些字符附加到字符串的末尾。
 * 例如：word = "abcde", k = 2
 * 初始状态: "abcde"
 * 1. 移除 "ab", 附加到末尾: "cdeab"
 * 2. 移除 "cd", 附加到末尾: "eabcd"
 * 3. 移除 "ea", 附加到末尾: "bcdea"
 * * 目标是找到最少的操作次数，使得字符串再次回到 "abcde" 的状态。
 * 这等价于找到一个操作次数 `m`，使得移除 `m * k` 个字符后，
 * 剩余的后缀（长度为 `n - m * k`）与原字符串的对应前缀完全匹配。
 * 也就是说，我们寻找是否存在一个 `m`，使得 `word[m*k ... n-1]` 等于 `word[0 ... n - m*k - 1]`。
 * * Z 算法在这里的作用是高效地检查一个后缀是否是原字符串的一个前缀。
 * Z[i] 恰好给出了从索引 i 开始的后缀与整个字符串前缀的最大匹配长度。
 * 如果 `Z[i] == n - i`，就意味着从索引 `i` 开始的后缀**完全**匹配了原字符串的长度为 `n - i` 的前缀。
 * * @param word 输入字符串
 * @param k 每次操作移除并附加的字符数
 * @return 恢复到初始状态所需的最小操作次数
 */
int minimumTimeToInitialState(string word, int k) {
    int n = word.size(); // 获取字符串的长度
    // 使用局部 vector 替代静态全局数组，避免线程安全问题。
    // vector 是 C++ STL 中的动态数组，比原始数组更安全灵活。
    vector<int> z(n);
    zArray(word, z); // 调用 Z 数组计算函数，填充 Z 数组。

    // 循环遍历可能的“匹配点”。
    // 每次操作移除 k 个字符，所以我们只关心索引为 k, 2k, 3k, ... 的位置。
    // 如果在某个位置 i (i = m * k) 找到了一个完美的后缀匹配，
    // 那么这表示在移除了 i 个字符（即 m 次操作）后，
    // 剩余的字符串 s[i...n-1] 已经与原字符串 s[0...n-i-1] 完全匹配。
    for (int i = k; i < n; i += k) {
        // 检查 Z 数组：如果 Z[i] 的值等于 `n - i`，
        // 这意味着从 `word[i]` 开始的后缀 (长度为 `n - i`)
        // 与 `word` 的前 `n - i` 个字符（即 `word[0...n-i-1]`）是完全相同的。
        // 这正是我们寻找的条件：经过 `i/k` 次操作后，字符串已经回到了初始状态。
        if (z[i] == n - i) {
            // 返回操作次数。i 是移除的字符总数，每次移除 k 个，所以操作次数是 i / k。
            return i / k;
        }
    }
    // 如果循环结束都没有找到一个完美的匹配点（即没有 `z[i] == n - i` 的情况），
    // 这意味着字符串需要完整地被“旋转”回来。
    // 例如 word = "abc", k = 2
    // n = 3
    // z = [3, 0, 0]
    // i = 2k = 2。
    // z[2] = 0。n - i = 3 - 2 = 1。z[2] != n - i。不满足条件。
    // 此时，需要进行 `(n + k - 1) / k` 次操作。这实际上是 ceil(n / k)。
    // 它表示将所有字符都从开头移除并附加到末尾所需的最少操作次数，
    // 无论中间是否出现重复，最终都会回到初始状态。
    // 例如 "abc", k = 2
    // 1. "abc" -> "cab" (移 "ab", 加 "ab")
    // 2. "cab" -> "bca" (移 "ca", 加 "ca")
    // 3. "bca" -> "abc" (移 "bc", 加 "bc")
    //  ceil(3 / 2) = 2。
    // 错误分析：这里应该思考的是，当没有一个后缀完美匹配前缀时，
    // 达到初始状态需要旋转 `n` 个字符。每次旋转 `k` 个，总共需要旋转 `n` 个字符。
    // 所需操作次数 = `ceil(n / k)`。
    // 比如 "abacaba", k = 3
    // n = 7, k = 3
    // Z-array: z[0]=7, z[1]=0, z[2]=1, z[3]=0, z[4]=3, z[5]=0, z[6]=1
    // i=3: z[3]=0, n-i = 7-3=4. 0 != 4.
    // i=6: z[6]=1, n-i = 7-6=1. 1 == 1!
    // 此时返回 6/3 = 2。
    // 2次操作：
    // "abacaba" -> "cabaaba" (移除 "aba")
    // "cabaaba" -> "abaacab" (移除 "cab")
    // 仍然不是初始状态。

    // 重新审视最后一个返回语句：
    // 如果没有任何一个 `i = m*k` 的位置满足 `z[i] == n - i`，
    // 那么这意味着字符串需要被完全“旋转”一整圈才能回到初始状态。
    // 每次操作移动 k 个字符，总共有 n 个字符。
    // 达到初始状态需要总共移动 n 个字符才能构成一个循环。
    // 例如 "abcde", k = 3
    // 1. "abcde" -> "deabc" (移除"abc")
    // 2. "deabc" -> "bcdea" (移除"dea")
    // 3. "bcdea" -> "eabcd" (移除"bcd")
    // 4. "eabcd" -> "abcde" (移除"eab")
    // 此时需要 4 次操作。
    // (n + k - 1) / k = (5 + 3 - 1) / 3 = 7 / 3 = 2 (整数除法)。显然不对。
    // 应该是 `ceil(n / k)` 次操作才能“移动完”整个字符串，然后我们再考虑是不是中间就有匹配。
    // 实际上，这里的 `(n + k - 1) / k` 是一个经典的向上取整公式 `ceil(a/b)`，
    // 它代表的是 **将长度为 `n` 的字符串，每次处理 `k` 个字符，需要多少次才能处理完**。
    // 如果没有提前找到匹配点，那么就必须完成所有字符的旋转，直到字符串再次回到其原始状态。
    // 而这个操作次数就是 `n/k` 的向上取整。
    return (n + k - 1) / k;
}
