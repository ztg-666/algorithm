#include <string>     // 包含字符串类，用于处理输入字符串
#include <vector>     // 包含向量容器，用于动态数组，例如存储处理后的字符串和回文半径
#include <algorithm>  // 包含算法函数，例如min函数，用于取两者最小值

// 不重叠回文子串的最多数目
// 给定一个字符串str和一个正数k
// 你可以随意把str切分成多个子串
// 目的是找到某一种划分方案，有尽可能多的回文子串
// 并且每个回文子串都要求长度>=k、且彼此没有重合的部分
// 返回最多能划分出几个这样的回文子串
// 测试链接 : https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/

using namespace std; // 使用标准命名空间，避免每次都写std::

// 辅助函数：find
// 🔍 这个函数是 Manacher 算法的局部变种，它的任务是在处理后的字符串 ss 中，
//    从指定起始位置 l 开始，查找第一个长度（在原字符串中）不小于 k 的回文子串。
//    如果找到，它将返回下一个非重叠搜索应该从 ss 数组的哪个位置开始；
//    如果找不到，则返回 -1。
// 参数：
// l: 当前搜索在处理后字符串 ss 中的起始索引。
// k: 要求的最小回文子串长度（在原字符串中）。
// ss: 经过 Manacher 预处理的字符向量（例如："aba" -> "#a#b#a#"）。
// p: 回文半径数组，p[i] 存储以 ss[i] 为中心的最长回文的半径。
// n: 处理后字符串 ss 的总长度。
int find(int l, int k, const vector<char>& ss, vector<int>& p, int n) {
    // 初始化 Manacher 算法的关键变量，但在一个局部扫描范围内：
    // c: 当前“最右回文”的中心 (Center)。“最右回文”是指其右边界 r 最大的回文子串。
    //    这里 c 初始化为 l，表示从当前搜索起点开始构建最右回文。
    // r: 当前“最右回文”的右边界 (Right boundary)。r = c + p[c]。
    //    同样初始化为 l，因为一开始没有已知的回文。
    int c = l, r = l;

    // 遍历处理后的字符串 ss，从指定起始位置 l 开始，计算每个位置 i 的回文半径 p[i]。
    for (int i = l; i < n; i++) {
        // 💫 **利用对称性加速** (Manacher 算法的精髓！)
        //    如果当前位置 i 在“最右回文”的覆盖范围内 (即 i < r)，
        //    那么 i 关于 c 的对称点是 `2 * c - i` (我们称之为 `mirror_i`)。
        //    此时，p[i] 的初始值至少是 p[mirror_i] 和 `r - i` 中的较小值。
        //    `r - i` 表示 i 到当前最右回文右边界的距离，这是 i 能向右扩展的最大长度。
        //    如果 i >= r，说明 i 在当前“最右回文”的右边或正好在边界上，
        //    此时无法利用对称性，我们从最小的回文半径1开始（即自身，如 '#' 或 'a'）。
        int len = (r > i) ? min(p[2 * c - i], r - i) : 1;

        // **中心扩展法**：在利用对称性预估的基础上，尝试继续扩展回文。
        // 扩展条件：
        // a. `i + len` 不越界 (不超出 ss 的右边界 n)
        // b. `i - len` 不越界 (不超出当前搜索的左边界 l) - 注意这里是 `l` 而不是 `0`
        // c. `ss[i + len]` 和 `ss[i - len]` 字符相等 (满足回文条件)
        while (i + len < n && i - len >= l && ss[i + len] == ss[i - len]) {
            len++; // 回文半径扩展！

            // 🎯 **关键判断：是否找到了符合长度 k 的回文？**
            //    在 ss 中，一个回文的半径是 `len`。它在原始字符串中的实际长度是 `len - 1`。
            //    因此，如果 `len - 1 >= k`，即 `len > k`，就表示找到了一个符合条件的回文。
            if (len > k) {
                // 找到了一个长度至少为 k 的回文！🎉
                // 现在需要计算下一个非重叠搜索的起始位置。
                // 这个回文在 ss 中以 i 为中心，半径为 len。
                // 由于我们只需要一个长度至少为 k 的回文，那么它在 ss 中的最小有效右边界是 i + k。
                // 为什么要考虑 ss[i+k] 的类型（字符还是'#'）？
                // 因为 ss 中的奇数索引位置是原始字符，偶数索引位置是 '#'。
                // 如果 ss[i+k] 是原始字符 (i+k 是奇数)，则表示这个字符是回文的实际结束点。
                //    下一个搜索应从该字符的下一个位置开始，即 i+k+1。 offset = 1。
                // 如果 ss[i+k] 是 '#' (i+k 是偶数)，则表示回文的实际结束点是 ss[i+k-1] (前一个字符)。
                //    下一个搜索应从 '#' 所在的位置开始，即 i+k。 offset = 0。
                int offset = (ss[i + k] != '#') ? 1 : 0;
                // 返回下一个搜索的起始索引。这个点确保了与当前找到的回文是“非重叠”的。
                return i + k + offset;
            }
        }

        // 5. **更新“最右回文”的中心 c 和右边界 r**
        //    如果当前以 i 为中心的回文子串的右边界 `i + len` 超过了当前的 `r`，
        //    说明我们找到了一个新的、向右扩展更远的回文，那么就需要更新 `c` 和 `r`。
        if (i + len > r) {
            r = i + len; // 更新最右边界 r
            c = i;       // 更新最右回文的中心 c
        }

        // 6. **存储当前位置 i 的回文半径**
        p[i] = len;
    }

    // 如果循环结束，没有找到任何符合长度 k 的回文子串，则返回 -1。
    return -1;
}

// 主函数：计算字符串中长度不小于 k 的非重叠回文子串的最大数量
// 🎁 这是提供给外部调用的接口，实现了贪心策略来解决问题。
int maxPalindromes(string str, int k) {
    int len = str.size(); // 获取原始字符串的长度
    // 计算处理后字符串 ss 的总长度。
    // 例如，原始字符串 "abc" (len=3)，处理后是 "#a#b#c#"，长度是 2*3 + 1 = 7。
    int n = len * 2 + 1;

    // 初始化处理后的字符向量 ss。
    vector<char> ss(n);
    // 填充 ss 数组：在每个字符前后插入分隔符 '#'。
    // 使用 (i % 2 == 0) 判断 i 是否为偶数，比位运算 (i & 1) == 0 更直观。
    for (int i = 0, j = 0; i < n; i++) {
        ss[i] = (i % 2 == 0) ? '#' : str[j++];
    }

    // 初始化回文半径数组 p。
    // p[i] 存储以 ss[i] 为中心的最长回文的“半径”。
    vector<int> p(n, 0);

    int ans = 0;  // 统计最终找到的非重叠回文子串的数量
    int next = 0; // 下一个搜索的起始位置，初始从 ss 的开头开始搜索

    // 采用贪心策略：循环查找并统计非重叠回文子串。
    // 每次找到一个符合条件的回文，就将其计入总数，然后将 `next` 更新到当前回文结束之后，
    // 以确保下一次搜索从不重叠的位置开始。
    while (true) {
        // 调用 find 函数，从 next 位置开始，查找第一个长度至少为 k 的回文。
        // find 返回的是下一个搜索的起始位置。
        int pos = find(next, k, ss, p, n);

        // 如果 find 返回 -1，表示在当前及后续位置无法再找到符合条件的回文，跳出循环。
        if (pos == -1) {
            break;
        }

        // 找到了一个符合条件的回文！计数加一。
        ans++;
        // 更新 next，确保下一次查找从当前找到的回文之后开始，实现非重叠。
        next = pos;
    }

    return ans; // 返回最大非重叠回文子串的数量
}
