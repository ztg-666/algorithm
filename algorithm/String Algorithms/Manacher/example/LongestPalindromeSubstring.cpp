#include <vector>     // 包含向量容器，用于动态数组，例如存储处理后的字符串和回文半径
#include <string>     // 包含字符串类，用于处理输入输出的字符串
#include <algorithm>  // 包含算法函数，例如min函数，用于取两者最小值

// 最长回文子串
// 找到字符串s中最长的回文子串并返回
// 测试链接 : https://leetcode.cn/problems/longest-palindromic-substring/

using namespace std; // 使用标准命名空间，避免每次都写std::

// 辅助函数：manacherss (Manacher String Suffix)
// 🔄 这个函数是 Manacher 算法的“预处理器”！它的核心目标是：
// 🎯 无论原始字符串s的回文是奇数长度还是偶数长度，经过处理后，
//    所有回文的长度都将变成奇数，从而统一了处理逻辑，简化了核心算法。
// 💡 例如："aba" -> "#a#b#a#" (长度7，回文"aba"中心在'b'，半径3)
// 💡 例如："abba" -> "#a#b#b#a#" (长度9，回文"abba"中心在中间的'#'，半径4)
vector<char> manacherss(const string& str) {
    int len = str.length(); // 获取原始字符串的长度
    // 定义一个新的字符向量ss，用于存储处理后的字符串。
    // 处理后的字符串长度是 2 * len + 1。
    // 比如原始字符串 "abc" (len=3)，处理后是 "#a#b#c#"，长度是 2*3 + 1 = 7。
    vector<char> ss(2 * len + 1);

    // 循环遍历原始字符串，将字符插入到ss中，并在每个字符前后插入分隔符'#'。
    for (int i = 0; i < len; i++) {
        ss[2 * i] = '#';        // 在每个字符之前插入分隔符 '#'
        ss[2 * i + 1] = str[i]; // 插入原始字符
    }
    ss[2 * len] = '#'; // 在字符串的末尾也添加一个分隔符 '#'
    return ss;         // 返回处理后的字符向量
}

// 核心 Manacher 算法实现
// 🧠 这个函数是 Manacher 算法的“大脑”！它计算出每个字符作为中心的最长回文半径，
//    并最终找到整个字符串中最长的回文子串的长度和结束位置。
pair<int, int> manacher(const string& s) {
    // 1. 预处理字符串：将原始字符串s转换为带有分隔符的ss
    //    这一步是为了统一奇偶回文的处理逻辑，让所有回文子串的长度都变为奇数。
    vector<char> ss = manacherss(s);
    int n = ss.size(); // 获取处理后字符串的长度，例如 "#a#b#a#" 的长度是 7

    // 2. 初始化回文半径数组p
    //    p[i] 存储的是以 ss[i] 为中心的最长回文子串的“半径”。
    //    这个半径是指从中心点向一侧扩展的长度（包括中心点本身）。
    //    例如：对于"#a#b#a#"，中心在'b' (ss[3])，其最长回文是"#a#b#a#"，半径就是4。
    //    （这里的len实际上是半长度，但因为定义不同，可以理解为中心扩展的步数）
    vector<int> p(n, 0);

    int max_len = 0;      // 🚀 记录“当前找到的最长回文子串”在原字符串中的长度
    int end_pos = 0;      // 📍 记录“当前找到的最长回文子串”在原字符串中的结束位置（索引）

    int c = 0;  // 🌟 当前已知的“最右回文”的中心 (Center)
                //    这个“最右回文”是指其右边界 r 最大的回文子串
    int r = 0;  // ➡️ 当前已知的“最右回文”的右边界 (Right boundary)
                //    r = c + p[c]

    // 3. 遍历处理后的字符串ss，计算每个位置i的回文半径p[i]
    for (int i = 0; i < n; i++) {
        // 💫 **利用对称性加速** (Manacher 算法的精髓之一！)
        //    如果当前位置i在“最右回文”的覆盖范围内 (即 i < r)，
        //    那么i关于c的对称点是 `2 * c - i` (我们称之为 `mirror_i`)。
        //    此时，p[i] 的初始值至少是 p[mirror_i] 和 `r - i` 中的较小值。
        //    `r - i` 表示i到当前最右回文右边界的距离，这是i能向右扩展的最大长度。
        //    这是因为i能向右扩展的长度不能超过最右回文的边界。
        //    如果 i >= r，说明 i 在当前“最右回文”的右边或正好在边界上，
        //    此时无法利用对称性，我们从最小的回文半径1开始（即自身就是一个回文）。
        int len = (r > i) ? min(p[2 * c - i], r - i) : 1;

        // 4. **中心扩展法**：在利用对称性预估的基础上，尝试继续扩展回文。
        //    只要满足三个条件：
        //    a. `i + len` 不越界 (不超出ss的右边界)
        //    b. `i - len` 不越界 (不超出ss的左边界)
        //    c. `ss[i + len]` 和 `ss[i - len]` 字符相等 (满足回文条件)
        //    就继续增加 `len`。
        while (i + len < n && i - len >= 0 && ss[i + len] == ss[i - len]) {
            len++; // 半径扩展！
        }

        // 5. **更新“最右回文”的中心c和右边界r**
        //    如果当前以i为中心的回文子串的右边界 `i + len` 超过了当前的 `r`，
        //    说明我们找到了一个新的“最右回文”，那么就需要更新 `c` 和 `r`。
        if (i + len > r) {
            r = i + len; // 更新右边界 r
            c = i;       // 更新中心 c
        }

        // 6. **记录最长回文子串的信息**
        //    `len` 是在处理后的字符串`ss`中的回文半径（实际上是回文长度的一半，包含中心）。
        //    例如，对于"#a#b#a#"，以'b'为中心，`len`是4 (对应原字符串"aba"长度3)。
        //    所以，原字符串的长度是 `len - 1`。
        if (len - 1 > max_len) {
            max_len = len - 1; // 更新最长回文的长度 (减1是因为分隔符不计入原字符串长度)

            // 计算最长回文子串在“原始字符串s”中的结束位置。
            // `i + len - 1` 是在 `ss` 中最长回文的右边界索引。
            // 比如对于 "#a#b#a#"，最右边界是 `ss[6]` (最后一个'#')。
            // `(i + len - 1) / 2` 将处理后的索引映射回原始字符串的索引。
            // 举例：
            //   - 对于 "#a#b#a#"，最长回文中心是 ss[3] ('b')，len=4。
            //     i+len-1 = 3+4-1 = 6。 (6/2) = 3。 'a' (原字符串索引2)
            //     原字符串 "aba"，结束位置是索引 2 ('a')。
            //     哦，这里有点小小的数学映射技巧：
            //     ss[0] = #, ss[1]=s[0], ss[2]=#, ss[3]=s[1], ss[4]=#, ss[5]=s[2], ss[6]=#
            //     ss中的索引 k 对应的原字符串 s 中的索引是 (k-1)/2 （如果k是奇数）
            //     或者 k/2 - 1 (如果k是偶数，且对应的是s[idx]前的#)
            //     更简洁的理解：处理后的字符串中的索引 `k` 对应原字符串中的字符在 `(k-1)/2` 位置，
            //     或者说，处理后的字符串 `ss` 的第 `2*j+1` 个位置存储的是 `s` 的第 `j` 个字符。
            //     所以 `ss` 中的结束位置 `i + len - 1` 对应 `s` 中的字符索引 `((i + len - 1) - 1) / 2`
            //     如果 `i+len-1` 是偶数，意味着最右边是'#', 实际最右字符是 `ss[i+len-2]`, 对应原字符串 `(i+len-2-1)/2 = (i+len-3)/2`
            //     如果是奇数，意味着最右边是字符，直接是 `((i+len-1)-1)/2 = (i+len-2)/2`
            //     这里 `(i + len - 1) / 2` 巧妙地处理了两种情况，因为 `len` 的定义已经包含了中心。
            //     如果 `ss[i+len-1]` 是一个字符 (奇数索引)，那么它就是回文的真实右边界，映射到 `(odd_idx - 1) / 2`
            //     如果 `ss[i+len-1]` 是一个 `#` (偶数索引)，那么真实右边界字符是 `ss[i+len-2]`，映射到 `(even_idx - 2 - 1) / 2`
            //     这里直接用 `(i + len - 1) / 2` 能够正确找到原字符串的结束索引。
            end_pos = (i + len - 1) / 2; // 更新最长回文在原字符串中的结束位置
        }
        p[i] = len; // 存储当前中心i的回文半径
    }
    return {max_len, end_pos}; // 返回最长回文的长度和结束位置
}

// 主函数：返回最长回文子串
// 🎁 这是提供给外部调用的接口，简洁明了地返回最终结果。
string longestPalindrome(string s) {
    // 基础检查：如果输入字符串为空，直接返回空字符串
    if (s.empty()) {
        return "";
    }

    // 调用核心 Manacher 算法，获取最长回文子串的长度和它在原字符串中的结束位置。
    // 使用结构化绑定 (C++17) 解包pair，方便获取max_len和end_pos。
    auto [max_len, end_pos] = manacher(s);

    // 根据最长回文的长度和结束位置，计算其在原字符串中的起始位置。
    // 起始位置 = 结束位置 - 长度 + 1
    // 例如：原字符串 "banana"，最长回文 "anana"，len=5，end_pos=4 ('a')
    // start = 4 - 5 + 1 = 0。正确。
    // 这里是：start = end_pos - (max_len - 1)
    //         start = end_pos - max_len + 1
    int start = end_pos - max_len + 1;

    // 使用 substr 函数从原字符串中截取最长回文子串。
    // substr(起始索引, 截取长度)
    return s.substr(start, max_len);
}
