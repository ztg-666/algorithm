#include<bits/stdc++.h> // 包含大部分标准库头文件，如iostream, string, vector, algorithm等

// 长度前k名的奇数长度回文子串长度乘积
// 给定一个字符串s和数值k，只关心所有奇数长度的回文子串
// 返回其中长度前k名的回文子串的长度乘积是多少
// 如果奇数长度的回文子串个数不够k个，返回-1
// 测试链接 : https://www.luogu.com.cn/problem/P1659

using namespace std; // 使用标准命名空间，避免每次都写std::

const int MOD = 19930726; // 定义模数，用于结果取模，避免整数溢出
const int MAXN = 10000001; // 定义最大字符串长度上限，例如可以处理10^7长度的字符串

int m, n;             // m: 原始字符串的长度；n: Manacher预处理后字符串的长度
long long k;          // k: 题目要求选择的回文子串的数量（或与此相关的预算），注意是long long类型
char ss[MAXN << 1];   // ss: 存储Manacher预处理后的字符串，例如"aba" -> "#a#b#a#"。MAXN << 1 等同于 MAXN * 2
                      // 长度为 MAXN 的原始字符串，预处理后长度最大为 2*MAXN + 1
int p[MAXN << 1];     // p: 存储Manacher算法计算出的回文半径数组。p[i]表示以ss[i]为中心的最长回文的半径
int cnt[MAXN];        // cnt: 存储每种奇数长度回文子串的数量。例如 cnt[3] 存储长度为3的回文数量

// 辅助函数：manacherss (Manacher String Preprocessor)
// 🔄 这个函数是 Manacher 算法的第一步：字符串预处理！
// 🎯 它的核心目标是将原始字符串 a 转换成一个新格式 (ss 数组)，
//    使得所有回文子串（无论是奇数长度还是偶数长度）在处理后的字符串中
//    都表现为奇数长度的回文，从而统一了算法处理逻辑，极大简化了问题。
// 💡 注意：此版本的预处理将原始字符放在了奇数索引，'#' 放在了偶数索引。
//    例如：原始字符串 "aba" -> 处理后 " #a#b#a# " (ss[0]='#', ss[1]='a', ss[2]='#', ...)
void manacherss(string a) {
    // 计算处理后字符串的总长度。
    // 原始长度为 a.size()，处理后是 2 * a.size() + 1。
    n = a.size() * 2 + 1;

    // 遍历填充 ss 数组。
    // 使用一个内部计数器 j 来追踪原始字符串的字符。
    // `(i & 1)` 是位运算技巧，用于判断 i 是否为奇数。
    // 如果 i 是奇数（1, 3, 5, ...），则在 ss[i] 处放置原始字符 a[j]，并递增 j。
    // 如果 i 是偶数（0, 2, 4, ...），则在 ss[i] 处放置分隔符 '#'。
    for (int i = 0, j = 0; i < n; i++) {
        ss[i] = (i & 1) ? a[j++] : '#';
    }
    ss[n] = '\0'; // 在末尾添加空字符，通常用于C风格字符串的兼容性或调试打印，对算法逻辑无直接影响。
}

// 核心 Manacher 算法实现
// 🧠 这个函数是 Manacher 算法的“大脑”！它遍历预处理后的字符串 ss，
//    计算并存储每个位置 i 的最长回文半径 p[i]。
void manacher(string str) {
    // 首先调用预处理函数，将原始字符串转换为 ss 数组并设置 n 的值。
    manacherss(str);

    // 初始化 Manacher 算法的关键变量：
    // i: 当前正在处理的中心位置在 ss 数组中的索引。
    // c: 当前“最右回文”的中心 (Center)。“最右回文”是指其右边界 r 最大的回文子串。
    // r: 当前“最右回文”的右边界 (Right boundary)。r = c + p[c]。
    // len: 临时变量，用于存储当前位置 i 的回文半径。
    for (int i = 0, c = 0, r = 0, len; i < n; i++) {
        // 💫 **利用对称性加速** (Manacher 算法的精髓之一！)
        //    如果当前位置 i 在“最右回文”的覆盖范围内 (即 i < r)，
        //    那么 i 关于 c 的对称点是 `2 * c - i` (我们称之为 `mirror_i`)。
        //    此时，p[i] 的初始值至少是 p[mirror_i] 和 `r - i` 中的较小值。
        //    `r - i` 表示 i 到当前最右回文右边界的距离，这是 i 能向右扩展的最大长度，
        //    因为它不能超过已经发现的最右回文的边界。
        //    如果 i >= r，说明 i 在当前“最右回文”的右边或正好在边界上，
        //    此时无法利用对称性，我们从最小的回文半径1开始（即自身，如 '#' 或 'a'）。
        len = r > i ? min(p[2 * c - i], r - i) : 1;

        // 4. **中心扩展法**：在利用对称性预估的基础上，尝试继续扩展回文。
        //    只要满足三个条件：
        //    a. `i + len` 不越界 (不超出 ss 的右边界 n)
        //    b. `i - len` 不越界 (不超出 ss 的左边界 0)
        //    c. `ss[i + len]` 和 `ss[i - len]` 字符相等 (满足回文条件)
        //    就继续增加 `len`。
        while (i + len < n && i - len >= 0 && ss[i + len] == ss[i - len]) {
            len++; // 回文半径扩展！
        }

        // 5. **更新“最右回文”的中心 c 和右边界 r**
        //    如果当前以 i 为中心的回文子串的右边界 `i + len` 超过了当前的 `r`，
        //    说明我们找到了一个新的、向右扩展更远的回文，那么就需要更新 `c` 和 `r`。
        if (i + len > r) {
            r = i + len; // 更新最右边界 r
            c = i;       // 更新最右回文的中心 c
        }

        // 6. **存储当前位置 i 的回文半径**
        p[i] = len;
    }
}

// 快速幂函数：计算 x 的 n 次方对 MOD 取模的结果
// 🚀 用于高效地计算 (base^exp) % MOD，时间复杂度为 O(log exp)。
long long power(long long x, long long n) {
    long long ans = 1; // 初始化结果为1
    x %= MOD;          // 确保底数在模数范围内，防止中间结果过大
    while (n > 0) {    // 当指数 n 大于0时循环
        if (n & 1) {   // 如果 n 是奇数 (n 的二进制表示的最低位是1)
            ans = (ans * x) % MOD; // 将当前底数 x 乘到结果中
        }
        x = (x * x) % MOD; // 底数 x 自乘，指数 n 减半 (通过位移 n >>= 1)
        n >>= 1;           // 指数 n 右移一位，相当于 n /= 2
    }
    return ans; // 返回最终结果
}

// 核心计算函数：根据 Manacher 结果计算特定要求的乘积
// 🎯 这个函数通过 Manacher 算法的结果 (p 数组) 统计不同长度的奇数回文子串，
//    并根据题目要求的 `k` 值，计算特定长度的乘积。
int compute(string s) {
    // 1. 运行 Manacher 算法，填充 p 数组。
    manacher(s);

    // 2. 统计所有奇数长度回文子串的频率。
    //    由于 `manacherss` 将原始字符放在了 `ss` 的奇数索引位置 (i=1, 3, 5...)，
    //    以这些奇数索引为中心的回文子串，在原始字符串中是奇数长度的回文。
    //    p[i] 是在 ss 中的回文半径，其对应的原始字符串中的长度是 p[i] - 1。
    for (int i = 1; i < n; i += 2) { // 只遍历 ss 中的奇数索引 (对应原始字符串中的字符中心)
        cnt[p[i] - 1]++; // 将对应原始长度的回文计数加一
    }

    long long ans = 1; // 初始化最终的乘积结果
    long long sum = 0; // 累计计数器，用于在循环中跟踪已处理的回文总数

    // 3. 遍历所有可能的奇数回文长度，从最长到最短，并计算乘积。
    //    循环条件 `k > 0` 确保我们只处理到满足 `k` 的要求为止。
    //    `len = (m & 1) ? m : (m - 1)`: 确保从不大于原始字符串长度 m 的最大奇数长度开始。
    for (int len = (m & 1) ? m : (m - 1); len >= 1 && k > 0; len -= 2) {
        // `sum` 累加当前长度 `len` 的回文数量。
        // 在每次迭代结束时，`sum` 存储的是：
        // `cnt[max_odd_len] + cnt[max_odd_len-2] + ... + cnt[current_len]`
        // 也就是所有长度大于或等于当前 `len` 的奇数回文子串的总数。
        sum += cnt[len];

        // 计算当前长度 `len` 在乘积中应出现的次数。
        // `min(k, sum)` 这里的 `k` 是当前剩余的“预算”或“需求数量”。
        // 这个表达式的含义是：
        // 如果 `sum` (即当前及更长回文的总数) 小于 `k`，则 `min(k, sum)` 为 `sum`。
        // 否则，`min(k, sum)` 为 `k`。
        // 这段逻辑是题目中对 `k` 个最长回文取乘积的一种特定实现。
        // 它会从最长的回文开始，将它们的长度乘以 `min(k, total_count_of_palindromes_so_far)` 次，
        // 从而有效地选取 `k` 个最长的回文并计算它们的长度乘积。
        ans = (ans * power(len, min(k, sum))) % MOD;

        // 减去当前处理的所有回文（即 `sum` 所代表的数量）对 `k` 的影响。
        // 这个 `k` 值会被传递到下一轮循环，影响 `min(k, sum)` 的计算，
        // 从而确保总共只考虑了 `k` 个回文。
        k -= sum;
    }

    // 4. 判断是否找到了足够的 k 个回文。
    // 如果循环结束后 `k` 仍然大于 0，说明没有足够的奇数长度回文来满足 `k` 的要求，返回 -1。
    // 否则，返回计算出的最终乘积 `ans`。
    return k > 0 ? -1 : (int)ans;
}

// 主函数
int main() {
    // 从标准输入读取原始字符串的长度 m 和要求的数量 k
    cin >> m >> k;

    string s; // 定义字符串 s
    cin >> s; // 从标准输入读取字符串 s

    // 清零 cnt 数组。
    // 这是一个重要的初始化步骤，确保每次运行时计数从0开始。
    memset(cnt, 0, sizeof(cnt));

    // 调用 compute 函数进行计算
    int result = compute(s);

    // 打印结果到标准输出
    printf("%d\n", result);

    return 0; // 程序正常结束
}
