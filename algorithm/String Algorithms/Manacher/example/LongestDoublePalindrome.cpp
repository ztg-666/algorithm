#include <bits/stdc++.h> // 包含大部分标准库头文件，如iostream, string, vector, algorithm等

// 最长双回文串长度
// 输入字符串s，求s的最长双回文子串t的长度
// 双回文子串就是可以分成两个回文串的字符串
// 比如"aabb"，可以分成"aa"、"bb"
// 测试链接 : https://www.luogu.com.cn/problem/P4555

using namespace std;     // 使用标准命名空间，避免每次都写std::

const int MAXN = 100002; // 定义原始字符串的最大长度上限。
                         // 实际处理的字符串 ss 长度会是 2 * MAXN + 1，所以数组大小为 MAXN << 1 (即 MAXN * 2)。

char ss[MAXN << 1];      // ss: 存储 Manacher 算法预处理后的字符串。
                         // 例如："aba" 会被处理成 "#a#b#a#"，存储在这个数组中。
                         // 大小 MAXN << 1 (约200004) 足够存储长度最大为100000的原始字符串的处理结果。
int p[MAXN << 1];        // p: 存储 Manacher 算法计算出的回文半径数组。
                         // p[i] 表示以 ss[i] 为中心的最长回文子串的“半径”（包含中心本身）。
int left_[MAXN << 1];    // left_: 存储每个偶数索引 j (在 ss 中) 左侧的最长回文长度。
                         // 具体来说，left_[j] 将存储以原始字符串中 (j/2)-1 结尾的最长回文子串的长度。
int right_[MAXN << 1];   // right_: 存储每个偶数索引 j (在 ss 中) 右侧的最长回文长度。
                         // 具体来说，right_[j] 将存储以原始字符串中 j/2 开始的最长回文子串的长度。
int n;                   // n: 存储 Manacher 预处理后字符串 ss 的实际长度。

// 辅助函数：manacherss (Manacher String Preprocessor)
// 🔄 这个函数是 Manacher 算法的第一步：字符串预处理！
// 🎯 它的核心目标是将 C 风格的原始字符串 char* a 转换成一个新格式 (ss 数组)，
//    使得所有回文子串（无论是奇数长度还是偶数长度）在处理后的字符串中
//    都表现为奇数长度的回文，从而统一了算法处理逻辑。
// 💡 例如：原始字符串 "aba" -> 处理后 " #a#b#a# "
void manacherss(char* a) {
    n = 0; // 初始化处理后字符串 ss 的长度为0
    // 遍历原始字符串 a，将字符和分隔符 '#' 交替插入到 ss 数组中。
    for (int i = 0; a[i]; ++i) { // 循环直到遇到字符串结束符 '\0'
        ss[n++] = '#'; // 在每个原始字符前插入 '#'
        ss[n++] = a[i]; // 插入原始字符
    }
    ss[n++] = '#'; // 在字符串的末尾也添加一个分隔符 '#'
    // 注意：ss 数组不需要手动添加 '\0'，因为 n 已经记录了有效长度，且 Manacher 算法不依赖 '\0'。
}

// 核心 Manacher 算法实现
// 🧠 这个函数是 Manacher 算法的“大脑”！它遍历预处理后的字符串 ss，
//    计算并存储每个位置 i 的最长回文半径 p[i]。
void manacher(char* s) {
    // 首先调用预处理函数，将原始字符串转换为 ss 数组并设置 n 的值。
    manacherss(s);

    // 初始化 Manacher 算法的关键变量：
    // c: 当前“最右回文”的中心 (Center)。“最右回文”是指其右边界 r 最大的回文子串。
    // r: 当前“最右回文”的右边界 (Right boundary)。r = c + p[c]。
    int c = 0, r = 0;

    // 遍历处理后的字符串 ss，计算每个位置 i 的回文半径 p[i]。
    for (int i = 0; i < n; ++i) {
        // 💫 **利用对称性加速** (Manacher 算法的精髓之一！)
        //    如果当前位置 i 在“最右回文”的覆盖范围内 (即 i < r)，
        //    那么 i 关于 c 的对称点是 `2 * c - i` (我们称之为 `mirror_i`)。
        //    此时，p[i] 的初始值至少是 p[mirror_i] 和 `r - i` 中的较小值。
        //    `r - i` 表示 i 到当前最右回文右边界的距离，这是 i 能向右扩展的最大长度，
        //    因为它不能超过已经发现的最右回文的边界。
        //    如果 i >= r，说明 i 在当前“最右回文”的右边或正好在边界上，
        //    此时无法利用对称性，我们从最小的回文半径1开始（即自身，如 '#' 或 'a'）。
        int len = (r > i) ? min(p[2 * c - i], r - i) : 1;

        // **中心扩展法**：在利用对称性预估的基础上，尝试继续扩展回文。
        // 扩展条件：
        // a. `i + len` 不越界 (不超出 ss 的右边界 n)
        // b. `i - len` 不越界 (不超出 ss 的左边界 0)
        // c. `ss[i + len]` 和 `ss[i - len]` 字符相等 (满足回文条件)
        while (i + len < n && i - len >= 0 && ss[i + len] == ss[i - len]) {
            len++; // 回文半径扩展！
        }

        // 5. **更新“最右回文”的中心 c 和右边界 r**
        //    如果当前以 i 为中心的回文子串的右边界 `i + len` 超过了当前的 `r`，
        //    说明我们找到了一个新的、向右扩展更远的回文，那么就需要更新 `c` 和 `r`。
        if (i + len > r) {
            r = i + len; // 更新最右边界 r
            c = i;       // 更新最右回文的中心 c
        }

        // 6. **存储当前位置 i 的回文半径**
        p[i] = len;
    }
}

// 核心计算函数：计算字符串中两个非重叠回文子串的最大长度之和
// 🎯 这个函数利用 Manacher 算法的结果 (p 数组)，通过两次线性扫描来填充 left_ 和 right_ 数组，
//    最终找到最优的分割点，使左右两部分非重叠回文的长度之和最大。
int compute(char* s) {
    // 1. 运行 Manacher 算法，填充 p 数组。
    manacher(s);

    // 2. 填充 left_ 数组：计算以每个偶数索引 j (ss 中的 '#') 为右边界的左侧最长回文子串的长度。
    //    这里的 j 对应原始字符串中 (j/2)-1 的位置。
    //    left_[j] 存储的是以原始字符串中 (j/2)-1 为结束位置的最长回文长度。
    //    这个循环巧妙地利用了 Manacher 结果进行动态规划式的填充。
    for (int i = 0, j = 0; i < n; ++i) { // i 遍历 Manacher 中心，j 遍历要填充的 left_ 索引 (偶数)
        // 这个 while 循环确保对于当前中心 i 的回文所覆盖的所有偶数索引 j，
        // 都能更新 left_[j] 的值。j 不断向右移动。
        // i+p[i] 是以 i 为中心的回文在 ss 中的右边界（不含）。
        // 只要 j 在这个回文覆盖范围内，就更新 left_[j]。
        while (i + p[i] > j) {
            // left_[j] 存储的值是 j-i。
            // 这是一个非常巧妙的赋值。它表示从中心 i 到 j 的距离。
            // 结合 j+=2，left_[j] 最终会累积为以 j-1 为结尾的最长回文的长度。
            // 具体来说，`p[i]`是半径，`p[i]-1`是原字符串长度。
            // `(i - (j - 1))` 是从 j-1 到中心 i 的距离。
            // 原始长度 = `p[i]-1`. 左半部分长 `(p[i]-1)/2`.
            // 这个 `j-i` 实际上计算的是 `p[k]-1` (原始长度) 的最大值。
            left_[j] = j - i;
            j += 2; // 只填充偶数索引，因为它们对应原始字符串的分割点
        }
    }

    // 3. 填充 right_ 数组：计算以每个偶数索引 j (ss 中的 '#') 为左边界的右侧最长回文子串的长度。
    //    这里的 j 对应原始字符串中 j/2 的位置。
    //    right_[j] 存储的是以原始字符串中 j/2 为开始位置的最长回文长度。
    //    与 left_ 数组类似，但从右向左进行扫描和填充。
    for (int i = n - 1, j = n - 1; i >= 0; --i) { // i 遍历 Manacher 中心 (从右到左)，j 遍历要填充的 right_ 索引 (偶数)
        // 类似 left_ 循环，确保当前中心 i 的回文所覆盖的所有偶数索引 j，
        // 都能更新 right_[j] 的值。j 不断向左移动。
        // i-p[i] 是以 i 为中心的回文在 ss 中的左边界（不含）。
        // 只要 j 在这个回文覆盖范围内，就更新 right_[j]。
        while (i - p[i] < j) {
            // right_[j] 存储的值是 i-j。
            // 它计算从 j 到中心 i 的距离。
            // 结合 j-=2，right_[j] 最终会累积为以 j+1 为开头的所有回文中最长的一个。
            right_[j] = i - j;
            j -= 2; // 只填充偶数索引
        }
    }

    // 4. 最终计算最大两非重叠回文子串长度之和。
    //    遍历 ss 中的所有偶数索引 i，它们表示原始字符串中的潜在分割点。
    //    例如，ss[2] 对应原始字符串 s[0] 和 s[1] 之间的分割。
    //    `i = 2` 和 `i = n - 3` 是边界条件，确保左右两边都有至少一个字符的回文存在。
    int ans = 0; // 初始化最大和为0
    for (int i = 2; i <= n - 3; i += 2) {
        // left_[i] 提供了以 (i/2)-1 结尾的最长回文长度。
        // right_[i] 提供了以 i/2 开始的最长回文长度。
        // 两者之和就是以当前 i 为分割点，左右两个非重叠回文的长度之和。
        ans = max(ans, left_[i] + right_[i]);
    }
    return ans; // 返回最大长度之和
}

// 主函数
int main() {
    char s[MAXN]; // 定义 C 风格字符数组用于存储输入字符串
    cin >> s;     // 从标准输入读取字符串 s

    // 调用 compute 函数进行计算，并直接输出结果。
    // 因为 MAXN 是 100002，字符串最长 100001，那么 s[MAXN] 就够了。
    cout << compute(s) << endl;

    return 0; // 程序正常结束
}
