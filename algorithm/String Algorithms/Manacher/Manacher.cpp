#include<bits/stdc++.h> // 包含大部分标准库，如iostream、string等。在 competitive programming 中常用。
using namespace std;     // 使用标准命名空间，避免每次写 std::

// Manacher算法模版
// 求字符串s中最长回文子串的长度
// 测试链接 : https://www.luogu.com.cn/problem/P3805



// 定义一个常量，用于设定字符串的最大长度。
// 通常会设置得比题目给定的最大N值稍大一些，以防止数组越界。
// 这里的 11000001 意味着原始字符串最大长度约为 1100万。
constexpr int MAXN = 11000001;

// 存储原始输入字符串。
// 初始化为 MAXN 大小的空格字符串，是为了确保有足够的空间。
string s_input(MAXN, ' ');

// 存储经过预处理（插入分隔符'#'）后的字符串。
// 预处理后的字符串长度是原始字符串长度的两倍加一，所以需要 2 * MAXN 的空间。
// 例如，"aba" -> "#a#b#a#"，长度从3变为7。
string ss(2*MAXN,' ');

// 存储回文半径数组。
// p[i] 表示以 ss[i] 为中心的最长回文子串的“半径”。
// 具体来说，如果 p[i] = k，则以 ss[i] 为中心的回文串长度为 2k-1（包括中心字符）。
// 这里的 k 其实是回文串（在 ss 中）的“半长度”，不包括中心字符的左右两边字符数。
// 例如，对于 "#a#b#a#"，ss[3] 是 'b'。如果 p[3] = 4，表示以 'b' 为中心，回文串是 "#a#b#a#"，长度是 2*4-1 = 7。
// 这里的 p[i] 实际上存储的是 Manacher 算法中回文串扩展的半长，包含中心字符本身。
// 例如，对于 "aba" 转换成 "#a#b#a#"，中心'b'在 ss[3]，其p[3]会是4，表示 "#a#b#a#" 是一个半径为4的回文串。
int p[2 * MAXN];

// 预处理后的字符串的长度。
int n;

/// @brief 对原始字符串进行预处理，插入分隔符 '#'。
/// @param a 原始字符串。
/// @param len 原始字符串的长度。
void manacherss(string a, int len) {
    // 预处理后的字符串长度是原始长度的两倍加一。
    // 例如，原始字符串 "aba" 长度为 3，预处理后 "#a#b#a#" 长度为 2*3+1 = 7。
    n = 2 * len + 1;
    // 遍历原始字符串和预处理后的字符串。
    // i 是 ss 的索引，j 是 a 的索引。
    for (int i = 0, j = 0; i < n; i++) {
        // 如果 i 是奇数 (i & 1)，则放置原始字符。
        // 如果 i 是偶数，则放置分隔符 '#'。
        // 这样可以统一处理奇数长度和偶数长度的回文串。
        // 例如：
        // i=0: ss[0] = '#'
        // i=1: ss[1] = a[0]
        // i=2: ss[2] = '#'
        // i=3: ss[3] = a[1]
        // ...
        ss[i] = (i & 1) ? a[j++] : '#';
    }
}

/// @brief Manacher 算法的主函数，用于计算最长回文子串的长度。
/// @param a 原始字符串。
/// @param len 原始字符串的长度。
/// @return 原始字符串中最长回文子串的长度。
int manacher(string a, int len) {
    // 首先调用预处理函数，将原始字符串转换为带分隔符的形式，并计算出 n。
    manacherss(a, len);

    // max_val 用于记录在预处理字符串中最长回文子串的“半径”。
    // 最终结果会根据它计算。
    int max_val = 0;

    // c (center) 表示当前已知的最右回文子串的中心。
    int c = 0;

    // r (right boundary) 表示当前已知的最右回文子串的右边界。
    // r = c + p[c] - 1。换句话说，以 c 为中心的最长回文子串的右端点（不包含）就是 r。
    // 这里 r 的定义是 "当前最右回文串的右边界+1"，即开区间 (c - p[c] + 1, c + p[c] - 1] 的右端点+1。
    int r = 0;

    // 遍历预处理后的字符串 ss，以每个字符作为潜在的回文中心。
    for (int i = 0; i < n; i++) {
        // cur_len 用于确定当前中心 i 的初始回文半径。
        // 如果 i 位于当前最右回文串 (c, r) 内部：
        // 我们可以利用对称性。i 关于 c 的对称点是 2 * c - i。
        // p[2 * c - i] 是对称点处的回文半径。
        // min(p[2 * c - i], r - i) 的含义是：
        // 1. p[2 * c - i]：以对称点为中心的回文半径，这部分是确定的，因为在 (c, r) 范围内。
        // 2. r - i：当前点 i 到最右边界 r 的距离。
        // 我们取这两者的最小值，是因为以 i 为中心的回文串，其在 r 之外的部分需要重新计算。
        // 如果 i 在 (c, r) 之外，或者刚好在 r 上，那么我们不知道其对称部分的信息，
        // 此时 cur_len 初始化为 1 (即只包含中心字符本身)。
        int cur_len = (r > i) ? min(p[2 * c - i], r - i) : 1;

        // 中心扩展法：
        // 尝试以 i 为中心，向两边扩展，检查字符是否相等。
        // 条件：
        //   i + cur_len < n：确保右侧没有越界。
        //   i - cur_len >= 0：确保左侧没有越界。
        //   ss[i + cur_len] == ss[i - cur_len]：左右对称位置的字符相等。
        while (i + cur_len < n &&
               i - cur_len >= 0 &&
               ss[i + cur_len] == ss[i - cur_len]) {
            cur_len++; // 如果相等，半径增加。
        }

        // 更新最右边界 r 和其对应的中心 c。
        // 如果以 i 为中心扩展的回文串的右边界 (i + cur_len) 超过了当前的 r，
        // 说明我们找到了一个更靠右的回文串，更新 c 和 r。
        if (i + cur_len > r) {
            r = i + cur_len; // r 是新回文串的右边界 + 1
            c = i;           // c 是新回文串的中心
        }

        // 更新全局最大回文半径。
        // max_val 存储的是所有 p[i] 中的最大值。
        // p[i] 存储的是以 ss[i] 为中心的回文串的“半径”。
        // 例如，对于 "#a#b#a#", p[3] = 4。这意味着以 ss[3] ('b') 为中心的最长回文串的长度是 2*4-1 = 7。
        if (cur_len > max_val) {
            max_val = cur_len;
        }
        // 将计算出的以 i 为中心的回文半径存入 p 数组。
        p[i] = cur_len;
    }
    // 返回最长回文子串的实际长度。
    // 因为 max_val 记录的是在预处理字符串中的“半径”，
    // 且这个半径是包含中心字符的（例如 #a#b#a#，p[3]=4 表示从中心'b'到两端各延伸3个字符，共7个字符）。
    // 在原字符串中，每两个原始字符之间都有一个 '#'。
    // 所以，如果在 ss 中回文串长度是 (2*max_val - 1)，那么原始字符串的长度就是 (max_val - 1)。
    // 例如：
    // ss 中最长回文半径是 max_val。
    // ss 中最长回文串的长度是 2*max_val - 1。
    // 由于分隔符的存在，实际原始字符的数量是 (2*max_val - 1 - 中间的分隔符数量) / 2 + 中间字符数量
    // 简而言之，经过推导，ss 中的回文半径减去 1 就是原始字符串的实际长度。
    return max_val - 1;
}

// 主函数，程序入口
int main() {
    // 关闭同步流，加速输入输出。在 competitive programming 中常用。
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 从标准输入读取字符串。
    cin >> s_input;
    // 获取输入字符串的长度。
    int len = s_input.size();
    // 调用 manacher 函数计算最长回文子串的长度并打印结果。
    cout << manacher(s_input, len) << endl;
    return 0; // 程序正常结束。
}
