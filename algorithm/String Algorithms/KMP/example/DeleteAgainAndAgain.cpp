#include <iostream> // 引入输入输出流库，用于标准输入输出操作，如cin、cout
#include <string>   // 引入字符串库，用于处理C++标准字符串类std::string
#include <cstring>  // 引入C风格字符串库，虽然在此代码中直接使用的不多，但有时会用于内存操作或某些兼容性函数（这里可能不必要，但保留无害）
using namespace std; // 使用标准命名空间，这样就无需在每次使用std::cin, std::cout, std::string时都加上std::前缀

// 定义一个常量MAXN，表示字符串的最大长度限制。
// 设定为1000001，这通常是为了处理百万级别字符的输入，确保数组有足够的空间。
const int MAXN = 1000001;

// 声明两个全局字符串变量s1和s2。
// s1是主字符串，我们将从中删除s2。
// s2是模式字符串，我们需要在s1中寻找并删除它。
string s1, s2;

// next_arr数组：这是KMP算法中的“部分匹配表”或“LPS（Longest Proper Prefix which is also Suffix）数组”。
// 它存储了模式字符串s2的每个前缀的最长公共前后缀的长度。
// 在匹配失败时，next_arr帮助我们决定模式串应该回溯到哪里，避免不必要的比较。
int next_arr[MAXN];

// stack1数组：它存储了s1中未被删除的字符的原始索引。
// 当字符被推入栈中时，我们记录它在s1中的原始位置。
// 这样，即使s1中的字符被删除，我们也可以通过这些索引还原剩余的有效字符串。
int stack1[MAXN];

// stack2数组：它存储了与stack1中对应字符匹配时，s2中的当前匹配进度（即s2的索引）。
// 例如，如果stack1[i]存储了s1的某个字符的索引，stack2[i]就存储了该字符在匹配s2时，s2当前匹配到的字符的索引。
// 这对于在删除一个完整匹配后，重新确定s2的匹配起始点至关重要。
int stack2[MAXN];

// size_变量：表示当前stack1和stack2中有效元素的数量，也就是当前“有效”字符串的长度。
// 它也被用作栈顶指针。
int size_;

/**
 * @brief nextArray函数：计算KMP算法中的next数组（部分匹配表）。
 * 这个函数会根据模式字符串s2生成next_arr，指导匹配过程中的回溯。
 * @param m 模式字符串s2的长度。
 */
void nextArray(int m) {
    next_arr[0] = -1; // next_arr[0]通常设置为-1，表示当匹配到s2[0]失败时，无需回溯，直接比较s1的下一个字符和s2的开头。
    if (m > 1) {       // 如果s2的长度大于1，才需要计算next_arr[1]及以后的值。
        next_arr[1] = 0; // next_arr[1]通常设置为0，表示s2[1]匹配失败时，回溯到s2[0]重新开始。
        int i = 2;       // i是当前正在计算next_arr的索引，从2开始（因为0和1已经设置）。
        int cn = 0;      // cn（current length）表示当前已知的最长公共前后缀的长度。
                         // 它也是s2中与s2[i-1]进行比较的字符的索引。
        while (i < m) {  // 遍历s2的每一个字符，计算其对应的next值，直到s2的末尾。
            if (s2[i - 1] == s2[cn]) { // 如果s2的当前字符(s2[i-1])与cn指向的字符(s2[cn])匹配，
                                       // 说明公共前后缀的长度可以增加。
                next_arr[i++] = ++cn;  // next_arr[i]设置为cn+1，然后i和cn都向前推进。
            } else if (cn > 0) {       // 如果不匹配，且cn不为0（说明之前有公共前后缀），
                                       // 则cn回溯到其next_arr值，尝试更短的公共前后缀。
                cn = next_arr[cn];
            } else {                   // 如果不匹配，且cn已经为0（无法再回溯），
                                       // 说明s2[i-1]没有匹配的公共前后缀，next_arr[i]设置为0。
                next_arr[i++] = 0;
            }
        }
    }
}

/**
 * @brief compute函数：执行主字符串s1中模式字符串s2的匹配和删除操作。
 * 它利用nextArray生成的next_arr以及两个栈来管理匹配状态和有效字符串。
 */
void compute() {
    size_ = 0;                     // 初始化size_为0，表示栈为空，当前有效字符串长度为0。
    int n = s1.length();           // 获取主字符串s1的长度。
    int m = s2.length();           // 获取模式字符串s2的长度。
    int x = 0;                     // x是主字符串s1的当前遍历索引。
    int y = 0;                     // y是模式字符串s2的当前匹配索引。

    nextArray(m);                  // 首先计算模式字符串s2的next数组。

    while (x < n) {                // 主循环：遍历主字符串s1中的所有字符。
        if (s1[x] == s2[y]) {      // Case 1: 当前主字符串字符与模式字符串字符匹配。
            stack1[size_] = x;     // 将s1中当前字符的原始索引存入stack1。
            stack2[size_] = y;     // 将s2中当前匹配进度（y）存入stack2。
            size_++;               // 栈顶指针和有效字符串长度增加。
            x++;                   // s1的索引向前推进。
            y++;                   // s2的匹配进度向前推进。
        } else if (y == 0) {       // Case 2: 当前主字符串字符与模式字符串字符不匹配，且模式串已回溯到起始位置y=0。
                                   // 这意味着s1[x]无法与s2[0]匹配，或者s2为空（y=0）。
            stack1[size_] = x;     // 将s1中当前字符的原始索引存入stack1。
            stack2[size_] = -1;    // 此时s2的匹配进度设置为-1，表示当前字符没有匹配到s2的任何部分。
                                   // 这是一个巧妙的标记，表示它不能作为s2匹配的有效前缀。
            size_++;               // 栈顶指针和有效字符串长度增加。
            x++;                   // s1的索引向前推进。
                                   // y保持为0，因为没有匹配成功，下次从s2[0]开始尝试。
        } else {                   // Case 3: 当前主字符串字符与模式字符串字符不匹配，但模式串未回溯到起始位置（y > 0）。
                                   // 此时需要利用next_arr进行回溯，将y移动到s2的下一个可能匹配位置。
            y = next_arr[y];       // y更新为next_arr[y]，继续尝试匹配s1[x]与s2[next_arr[y]]。
        }

        if (y == m) {              // 检查：如果y等于m，说明整个模式字符串s2已经完全匹配成功！
            size_ -= m;            // 匹配成功，需要从“有效”字符串中删除这m个字符。
                                   // 简单地将size_减去m，就相当于从栈顶弹出了m个元素。
            // 关键的回溯点：重置y以继续下一次匹配。
            // 如果栈中还有元素（size_ > 0），则新的匹配应该从栈顶元素所对应的s2匹配进度 + 1 的位置开始。
            // 否则（栈空），从s2的起始位置0开始。
            // 这样处理能够正确处理重叠匹配的情况，例如从"ababab"中删除"aba"：
            // 第一次匹配"aba"后，栈中剩下"aba"，y会恢复到匹配"aba"时最后一个'a'的匹配进度+1，即'b'的位置。
            y = (size_ > 0) ? (stack2[size_ - 1] + 1) : 0;
        }
    }
}

// 不停删除之后剩下的字符串
// 给定一个字符串s1，如果其中含有s2字符串，就删除最左出现的那个
// 删除之后s1剩下的字符重新拼接在一起，再删除最左出现的那个
// 如此周而复始，返回最终剩下的字符串
// 测试链接 : https://www.luogu.com.cn/problem/P4824

/**
 * @brief main函数：程序的入口点。负责处理输入、调用核心逻辑并输出结果。
 */
int main() {
    // 优化输入输出流，提高程序执行效率。
    // ios::sync_with_stdio(false) 禁止C++标准流与C标准流同步，
    // cin.tie(0) 解除cin与cout的绑定，避免cin在每次输入前刷新cout。
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 读取主字符串s1和模式字符串s2。
    // 使用getline而非cin >> 是因为s1和s2可能包含空格。
    getline(cin, s1);
    getline(cin, s2);

    compute(); // 调用compute函数执行字符串的匹配与删除操作。

    // 遍历stack1中剩余的有效索引，并根据这些索引从原始s1中取出字符打印。
    // 这样就构成了删除s2后的最终字符串。
    for (int i = 0; i < size_; i++) {
        cout << s1[stack1[i]];
    }
    cout << '\n'; // 输出一个换行符，确保输出的格式正确。

    return 0; // 程序成功执行完毕，返回0。
}
