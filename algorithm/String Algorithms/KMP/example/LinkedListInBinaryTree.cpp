#include <vector> // 引入C++标准库中的vector容器，用于动态数组

// 二叉树中的链表
// 给你一棵以root为根的二叉树、一个以head为头的链表
// 在二叉树中，有很多一直向下的路径
// 如果某个路径上的数值等于以head为头的整个链表
// 返回True，否则返回False
// 测试链接 : https://leetcode.cn/problems/linked-list-in-binary-tree/

using namespace std; // 使用标准命名空间，避免每次使用标准库组件时都写std::

// 链表节点定义（题目提供，实际提交时无需重复）
// 这是一个结构体，用于表示链表的单个节点。
// 每个节点包含一个整数值 (val) 和一个指向下一个节点的指针 (next)。
struct ListNode {
    int val;         // 节点存储的整数值
    ListNode *next;  // 指向链表中下一个节点的指针

    // 默认构造函数：创建一个值为0，next指向空指针的节点。
    ListNode() : val(0), next(nullptr) {}

    // 带参构造函数：创建一个值为x，next指向空指针的节点。
    ListNode(int x) : val(x), next(nullptr) {}
};

// 二叉树节点定义（题目提供，实际提交时无需重复）
// 这是一个结构体，用于表示二叉树的单个节点。
// 每个节点包含一个整数值 (val) 和两个指向其左右子节点的指针 (left, right)。
struct TreeNode {
    int val;         // 节点存储的整数值
    TreeNode *left;  // 指向左子树根节点的指针
    TreeNode *right; // 指向右子树根节点的指针

    // 默认构造函数：创建一个值为0，左右子节点都为空指针的节点。
    TreeNode() : val(0), left(nullptr), right(nullptr) {}

    // 带参构造函数：创建一个值为x，左右子节点都为空指针的节点。
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 计算 next 数组（KMP 预处理）
// 这个函数是 KMP 算法的核心预处理步骤。
// 它根据模式串 (s，这里是链表转换成的数组) 计算出其 'next' (或称 'border') 数组。
// next[i] 存储的是模式串 s[0...i-1] 的最长公共前缀后缀的长度。
// 这个数组在匹配失败时，指示模式串应该回溯到哪个位置继续比较，从而避免不必要的比较。
vector<int> nextArray(vector<int>& s, int m) {
    // 思考：如果模式串长度为1，其next数组是什么？
    // 只有一个字符的模式串，没有“真”前缀和“真”后缀，所以next[0]应该为-1（特殊约定）。
    if (m == 1) {
        return {-1}; // KMP约定，next[0]通常为-1，表示无法再回溯，需要文本串前进。
    }

    // 初始化 next 数组，大小为 m (模式串长度)。
    vector<int> next(m, 0);
    next[0] = -1; // 模式串的第一个字符，其最长公共前后缀长度为-1（无法匹配时直接移动文本串指针）。
    next[1] = 0;  // 模式串的第二个字符，其前缀s[0]和后缀s[0]长度为0（空字符串）。

    // i 是当前正在计算 next 值的模式串的索引 (从 2 开始，因为 next[0] 和 next[1] 已初始化)。
    // cn (common_prefix_suffix_length) 是当前最长公共前后缀的长度。
    int i = 2, cn = 0;

    // 循环直到遍历完模式串的所有字符。
    while (i < m) {
        // 情况1: s[i-1] == s[cn]
        // 如果当前要比较的字符 s[i-1] (模式串的第 i-1 个字符) 等于 s[cn] (当前最长公共前后缀的下一个字符)，
        // 这意味着我们可以将公共前后缀的长度增加 1。
        if (s[i - 1] == s[cn]) {
            next[i++] = ++cn; // next[i] 被设置为 cn+1，然后 i 和 cn 都自增。
        }
        // 情况2: cn > 0 (但 s[i-1] != s[cn])
        // 如果当前字符不匹配，并且 cn > 0，说明之前有匹配的前缀后缀。
        // 此时，我们需要利用 next 数组回溯 cn，找到其更短的公共前后缀，继续尝试匹配。
        else if (cn > 0) {
            cn = next[cn]; // 回溯到更短的公共前后缀的长度。
        }
        // 情况3: cn == 0 (且 s[i-1] != s[cn])
        // 如果当前字符不匹配，且 cn 已经为 0，说明没有公共前缀后缀可以利用了。
        // 此时，next[i] 设为 0，表示从头开始匹配，并且 i 自增。
        else { // cn == 0
            next[i++] = 0; // next[i] 设置为 0。
        }
    }
    return next; // 返回计算好的 next 数组。
}

// 递归匹配二叉树路径 (KMP 匹配过程)
// 这个函数通过深度优先搜索 (DFS) 遍历二叉树，并在每个节点处尝试使用 KMP 算法匹配链表序列。
// s2: 链表转换而来的模式串 (vector<int>)。
// next: s2 对应的 KMP next 数组。
// cur: 当前正在访问的二叉树节点。
// i: 当前模式串 s2 中匹配到的位置 (s2[0...i-1] 已经匹配成功)。
bool find(vector<int>& s2, vector<int>& next, TreeNode* cur, int i) {
    // 思考：匹配成功或失败的终止条件是什么？
    // 终止条件1: 模式串 s2 已经完全匹配成功。
    if (i == s2.size()) {
        return true; // 恭喜！链表序列在二叉树的这条路径中找到了！🥳
    }
    // 终止条件2: 二叉树当前节点为空，但模式串 s2 尚未完全匹配。
    // 这意味着这条路径无法继续，因此匹配失败。
    if (cur == nullptr) {
        return false; // 路径中断，匹配失败。
    }

    // KMP 回溯匹配位置：
    // 当 cur->val (二叉树节点值) 不等于 s2[i] (模式串当前要匹配的字符) 时，
    // 我们需要利用 next 数组回溯模式串的匹配位置 'i'。
    // 这正是 KMP 算法避免文本串指针回溯的精髓所在。
    // 'i' 会根据 next 数组跳到更短的匹配前缀的下一个位置，直到 i 变为 -1 或 s2[i] == cur->val。
    while (i >= 0 && cur->val != s2[i]) {
        i = next[i]; // 根据 next 数组进行回溯。
    }

    // 经过 KMP 回溯后，如果 'i' 变为 -1，说明从头开始匹配 s2[0]；
    // 如果 'i' 没有变为 -1 且 cur->val == s2[i]，说明当前字符匹配成功。
    // 无论哪种情况，都将 'i' 自增 1，表示模式串的匹配位置向前推进一位。
    // 例如，如果 i 从 -1 变为 0，意味着 s2[0] 匹配成功。如果 i 从 k 变为 k+1，意味着 s2[k] 匹配成功。
    i++; // 模式串匹配位置向前推进一位。

    // 递归地尝试在左右子树中继续匹配。
    // 只要左子树或右子树中有一条路径能够完全匹配链表，就返回 true。
    // 注意：这里的 i+1 是 KMP 的关键。即使当前节点匹配成功，下一节点也需要从 i+1 处开始匹配链表。
    // KMP的匹配过程中，模式串指针i表示当前匹配成功的模式串前缀的长度。
    // 如果当前节点值 cur->val 与 s2[i] 匹配，那么下一个要匹配的模式串字符是 s2[i+1]。
    // 因此，在递归调用时，i 参数需要传递 (匹配成功后) i+1，代表模式串下一个期望匹配的位置。
    return find(s2, next, cur->left, i) || // 尝试在左子树中继续搜索
           find(s2, next, cur->right, i);  // 尝试在右子树中继续搜索
}

// 主函数：判断链表是否在二叉树路径中存在
// 这是整个解决方案的入口点。
bool isSubPath(ListNode* head, TreeNode* root) {
    // 思考：如何将链表转换为 KMP 算法可以处理的“模式串”？
    // 第一步：将链表转换为一个整数向量 (vector<int>)，便于 KMP 算法处理。
    vector<int> s2;
    ListNode* tmp = head; // 临时指针，用于遍历链表。
    while (tmp != nullptr) {
        s2.push_back(tmp->val); // 将链表节点的值添加到向量中。
        tmp = tmp->next;        // 移动到下一个链表节点。
    }

    // 思考：KMP 算法的预处理步骤是什么？
    // 第二步：计算链表（作为模式串）的 KMP next 数组。
    // 这个 next 数组将指导匹配过程中的回溯。
    vector<int> next = nextArray(s2, s2.size());

    // 思考：如何在二叉树中启动 KMP 匹配？
    // 第三步：在二叉树中搜索匹配路径。
    // 从二叉树的根节点 root 开始，尝试匹配模式串 s2。
    // 初始匹配位置 i 为 0，表示从模式串 s2 的第一个字符开始尝试匹配。
    // 这里的关键是：二叉树的每个节点都可能成为链表匹配的起点。
    // 因此，我们需要对二叉树进行深度优先遍历，对于每个节点都调用 `find` 函数，
    // 尝试以该节点为 KMP 匹配的“文本串”的起点。
    // 这个逻辑在 `find` 函数的入口处体现：`find(s2, next, cur, 0)` 中的 `0`。
    // 但是，主函数 `isSubPath` 调用的 `find(s2, next, root, 0)` 只是从根节点开始匹配。
    // 如果链表不一定从二叉树的根节点开始，那么 `find` 函数的逻辑需要进一步调整，
    // 使得 `find` 函数可以从任意一个二叉树节点开始重新尝试 KMP 匹配。

    // 让我们重新审视 `find` 函数和 `isSubPath` 的设计。
    // 当前 `find` 函数的设计是：如果当前 `cur` 节点和 `s2[i]` 匹配成功，
    // 则 `i` 递增。如果匹配失败，`i` 会根据 `next` 数组回溯。
    // 这意味着 `find(s2, next, cur, i)` 试图从 `cur` 开始，**在当前路径上** 匹配 `s2[i:]`。
    // 那么，如果链表是从二叉树的某个非根节点开始匹配的呢？
    // 例如，链表是 `1->2`，二叉树是 `0->1->2`。
    // `isSubPath(head, root)` 第一次调用 `find(s2, next, root, 0)`。
    // `root` 是 `0`，`s2[0]` 是 `1`，不匹配。`i` 会回溯到 `next[0]` (即 -1)。
    // 之后 `i` 变为 `0`。
    // 接着递归调用 `find(s2, next, root->left, 0)` 和 `find(s2, next, root->right, 0)`。
    // 假设 `root->left` 是 `1`。
    // `find(s2, next, node_1, 0)`：`node_1->val` 是 `1`，`s2[0]` 是 `1`，匹配。`i` 变为 `1`。
    // 接着递归调用 `find(s2, next, node_1->left, 1)` 和 `find(s2, next, node_1->right, 1)`。
    // 假设 `node_1->right` 是 `2`。
    // `find(s2, next, node_2, 1)`：`node_2->val` 是 `2`，`s2[1]` 是 `2`，匹配。`i` 变为 `2`。
    // 此时 `i == s2.size()` (假设 s2 长度为 2)，返回 `true`。

    // 结论：
    // 现有的 `find` 函数实际上是 **在任何二叉树节点上，都尝试从链表的头部 (i=0) 开始匹配**。
    // 如果当前二叉树节点的值与链表的头部值不匹配，`find` 函数中的 KMP 回溯逻辑 (`while (i >= 0 && cur->val != s2[i]) { i = next[i]; }`)
    // 会将 `i` 回溯，最终可能会变成 `0` (如果从 `-1` 变过来) 或其他值，然后 `i++`。
    // 核心思想是，对于二叉树中的每一个节点 `cur`，我们都尝试以 `cur` 作为匹配链表的起点。
    // 这就是为什么 `find` 函数的递归调用不需要传递一个修改后的 `i` 参数来表示“重新开始匹配”。
    // 而是通过 `find` 函数内部的 KMP 匹配逻辑（即 `while` 循环），
    // 使得每个递归调用 `find(s2, next, next_node, i_after_match)` 都能正确地在当前路径上进行 KMP 匹配。
    // 如果当前 `cur->val` 与 `s2[i]` 不匹配，KMP 会回溯 `i`。如果 `i` 最终回溯到 0 甚至 -1，
    // 那么下一个节点 `next_node` 也会从 `i` (回溯后的值) 处继续尝试匹配。
    // 这样，在 `isSubPath` 中只需要从 `root` 开始调用一次 `find`。
    // 至于为什么 `find` 函数的 `i` 是在当前递归层级就确定，而不是在递归调用时重置为0，这是KMP算法的特性。
    // 因为 KMP 是一个状态机，`i` 代表当前匹配的模式串长度。
    // 在 KMP 匹配中，一旦模式串的某个前缀与文本串的某个后缀匹配成功，那么这个匹配状态 (由 `i` 表示) 就会传递下去。
    // KMP 避免了文本串指针的回溯，而是通过调整模式串的指针 `i` 来实现高效匹配。

    // 所以，最终的逻辑是：对于二叉树中的每个节点，都将其视为可能的链表起始点。
    // 这是通过在 `find` 函数的递归调用中，始终传递 `i` 参数来实现的。
    // `find(s2, next, root, 0)` 只是启动了从 `root` 沿着所有路径的 KMP 搜索。
    // 每一个二叉树节点，当它被访问时，`find` 函数都会尝试将它与 `s2[i]` 进行比较。
    // 如果 `cur->val == s2[i]`，则 `i` 增加。
    // 如果 `cur->val != s2[i]`，则 `i` 回溯。
    // 这样的设计使得 KMP 匹配能够“连续地”在二叉树路径上进行。

    return find(s2, next, root, 0); // 从二叉树的根节点开始，匹配链表的第一个元素 (i=0)。
}

