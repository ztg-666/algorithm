#include <bits/stdc++.h> // 包含所有标准库头文件，这是一个在竞技编程中常见的做法，但对于大型项目，推荐按需包含具体的头文件以提高编译速度和清晰度。

// 统计有多少个不同的字符串
// 测试链接 : https://www.luogu.com.cn/problem/P3370

using namespace std;     // 使用标准命名空间。同样，在大型项目中，为了避免命名冲突，通常建议显式地使用 std:: 前缀，或者只导入特定的名称。

const int MAXN = 10001;  // 定义一个常量MAXN，表示处理字符串的最大数量。这是一个常见的做法，用于预先分配数组大小，避免越界，并使代码更易于维护。
                         // 这里设置为10001，意味着可以处理最多10000个字符串。
const int base = 499;    // 定义哈希函数中的基数（或乘数）。选择一个合适的质数作为基数对于减少哈希冲突至关重要。
                         // 499是一个质数，通常情况下，质数能提供更好的哈希分布。
long long nums[MAXN];    // 声明一个 long long 类型的数组 nums，用于存储每个字符串计算出的哈希值。
                         // 为什么是 long long？因为哈希值在连续乘以 base 后可能会变得非常大，超过 int 的存储范围。
int n;                   // 声明一个整型变量 n，用于存储输入的字符串数量。

// 函数名：v
// 功能：将字符转换为对应的数值。这是哈希函数中将单个字符映射到数字的基础步骤。
// 参数：char c - 待转换的字符。
// 返回值：int - 转换后的数值。
// 转换规则：
//   - 数字 '0'-'9' 映射到 1-10。
//   - 大写字母 'A'-'Z' 映射到 11-36。
//   - 小写字母 'a'-'z' 映射到 37-62。
// 这种映射方式确保了所有字符都有一个正整数值，且不同类型的字符有不同的值域，有助于哈希的区分度。
int v(char c) {
    if (c >= '0' && c <= '9') {
        return c - '0' + 1; // '0' -> 1, '1' -> 2, ..., '9' -> 10
    } else if (c >= 'A' && c <= 'Z') {
        return c - 'A' + 11; // 'A' -> 11, 'B' -> 12, ..., 'Z' -> 36
    } else { // 假设只包含数字、大写字母、小写字母，这里处理小写字母
        return c - 'a' + 37; // 'a' -> 37, 'b' -> 38, ..., 'z' -> 62
    }
}

// 函数名：value
// 功能：计算给定字符串的哈希值。这里使用的是一个多项式哈希（Polynomial Hashing）的变种。
// 原理：将字符串看作一个 base 进制的数字。例如，字符串 "abc" 的哈希值可以表示为 (v('a') * base^2 + v('b') * base^1 + v('c') * base^0)。
// 优点：这种哈希方法简单且通常能提供较好的均匀分布，有效地将字符串压缩成一个数值。
// 参数：const string& s - 待计算哈希值的字符串。使用 const string& 可以避免不必要的字符串拷贝，提高效率。
// 返回值：long long - 计算出的字符串哈希值。
long long value(const string& s) {
    long long ans = v(s[0]); // 初始化哈希值为字符串的第一个字符的数值。
                            // 想象成 base 进制数的最高位。
    for (size_t i = 1; i < s.length(); i++) { // 从第二个字符开始遍历字符串。
        ans = ans * base + v(s[i]); // 核心哈希计算步骤：当前哈希值乘以基数再加上下一个字符的数值。
                                   // 这就是多项式哈希的“滚动”计算过程。
    }
    return ans; // 返回最终计算的哈希值。
}

// 函数名：cnt
// 功能：统计 nums 数组中不同哈希值的数量，从而间接统计不同字符串的数量。
// 原理：先对哈希值数组进行排序，然后遍历排序后的数组，统计相邻不相同的元素个数。
// 优点：通过排序，相同的哈希值会聚集在一起，使得去重操作变得非常简单和高效。
// 前提：该方法依赖于哈希函数能够有效地区分不同的字符串，即哈希冲突的概率足够低。
// 返回值：int - 不同哈希值的数量。
int cnt() {
    sort(nums, nums + n); // 对存储哈希值的数组 nums 进行升序排序。
                          // `nums` 是数组的起始地址，`nums + n` 是数组的结束地址（即第一个不包含的元素的地址）。
    int ans = 1;          // 初始化不同数量为1，因为至少有一个字符串（如果 n > 0）。
                          // 如果 n 为 0，这个初始化需要调整，但根据后续循环条件，n=0时循环不会执行，ans会保持1，这是个小bug，
                          // 更好的做法是 if (n == 0) return 0;
    for (int i = 1; i < n; i++) { // 从第二个元素开始遍历排序后的数组。
        if (nums[i] != nums[i - 1]) { // 检查当前元素是否与前一个元素不同。
            ans++; // 如果不同，则说明发现了一个新的唯一的哈希值，计数器加1。
        }
    }
    return ans; // 返回最终的不同哈希值数量。
}

// 主函数
// 功能：程序的入口点。负责读取输入、调用哈希函数计算哈希值、调用统计函数并输出结果。
int main() {
    cin >> n; // 读取输入的字符串数量 n。

    for (int i = 0; i < n; i++) { // 循环 n 次，读取每个字符串并计算其哈希值。
        string s;           // 声明一个字符串变量 s。
        cin >> s;           // 读取一个字符串。
        nums[i] = value(s); // 调用 value 函数计算字符串 s 的哈希值，并将其存储在 nums 数组的第 i 个位置。
    }

    cout << cnt() << endl; // 调用 cnt 函数统计不同哈希值的数量（即不同字符串的数量），并将结果输出到控制台。
                           // endl 会在输出后换行并刷新缓冲区。
    return 0; // 程序成功执行，返回0。
}
