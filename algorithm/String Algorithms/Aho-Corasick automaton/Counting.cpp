#include <iostream>  // 标准输入输出库
#include <cstring>   // 字符串操作库，用于memset
#include <vector>    // 向量库 (虽然在这个代码中没有直接用到，但通常是C++常用库)
#include <queue>     // 队列库，用于AC自动机构建中的BFS

// 数数(利用AC自动机检查命中)
// 我们称一个正整数x为幸运数字的条件为
// x的十进制中不包含数字串集合s中任意一个元素作为子串
// 例如s = { 22, 333, 0233 }
// 233是幸运数字，2333、20233、3223不是幸运数字
// 给定n和s，计算不大于n的幸运数字的个数
// 答案对1000000007取模
// 测试链接 : https://www.luogu.com.cn/problem/P3311


using namespace std; // 使用标准命名空间，避免每次写std::

// 定义常量
const int MOD = 1000000007; // 模数，用于结果取模，防止整数溢出，因为答案可能非常大
const int MAXN = 1301;      // 最大数字位数上限，题目通常会给出N的长度限制，这里是1300位
const int MAXS = 2001;      // AC自动机节点数上限，取决于所有模式串的总长度，这里是2000个节点

char num[MAXN];        // 存储输入的大数字N，以字符串形式表示，因为N可能非常大
int n;                 // 输入数字N的长度

// === AC自动机数据结构定义 ===
// tree[u][idx]: 表示AC自动机中节点u通过字符idx转移到的下一个节点。
//             实际上是Trie树的结构，每个节点有10个子节点（对应数字0-9）。
int tree[MAXS][10];
// fail[u]: 失败指针，当当前字符无法匹配时，沿着失败指针跳转到下一个可能匹配的状态。
//          这是AC自动机的核心，使得它能高效处理多个模式匹配。
int fail[MAXS];
// alert[u]: 危险节点标记。如果节点u代表的路径（或通过其失败指针回溯到的路径）
//           是任何一个禁止子串的结尾，则alert[u]为true。
bool alert[MAXS];
int cnt;               // AC自动机节点计数器，用于分配新节点ID

// === 记忆化DP数组定义 ===
// dp[i][j][free][has]:
// i: 当前正在考虑的数字位（从左到右，0到n-1）
// j: 当前在AC自动机中的节点状态
// free: 自由选择标志。
//       - free = 0: 当前位及其后续位的选择受到num[i]的限制（只能选0到num[i]）。
//       - free = 1: 当前位及其后续位的选择是自由的（可以选0到9），因为前面已经选了一个小于num[i]的数字。
// has: 已有数字标志。
//      - has = 0: 至今为止（包括当前位）还未选择过任何非零数字（当前数字序列都是前导零，或者根本没选数字）。
//                 在这种状态下，可以继续选择0作为前导零，或者选择1-9开始一个有效数字。
//      - has = 1: 已经选择了至少一个非零数字，意味着当前序列已经是一个有效的数字（非前导零）。
//                 在这种状态下，可以自由选择0-9。
// 数组值：表示从当前状态(i, j, free, has)到数字末尾，能构成多少个不含禁止子串的有效数字。
int dp[MAXN][MAXS][2][2];

// 清空DP表，将其所有元素初始化为-1，表示该状态尚未计算
void clear() {
    // 使用memset高效地将整个dp数组填充为-1。
    // 因为-1在int类型中通常表示未访问/未计算的状态，且不会与有效计数（非负数）混淆。
    memset(dp, -1, sizeof(dp));
}

// === AC自动机：插入模式串 ===
// 将一个模式串（禁止子串）插入到AC自动机（Trie部分）中
void insert(string word) {
    int u = 0; // 从根节点（节点0）开始
    for (char c : word) { // 遍历模式串中的每一个字符
        int idx = c - '0'; // 将字符转换为对应的数字索引 (e.g., '0' -> 0, '1' -> 1)
        if (!tree[u][idx]) { // 如果当前节点u没有通过字符idx的子节点
            tree[u][idx] = ++cnt; // 则创建一个新节点，并更新节点计数器
        }
        u = tree[u][idx]; // 移动到下一个节点
    }
    alert[u] = true; // 模式串的最后一个字符对应的节点标记为“危险”节点，表示匹配到一个禁止子串
}

// === AC自动机：构建失败指针 ===
// 使用BFS（广度优先搜索）构建AC自动机的失败指针
void setFail() {
    queue<int> q; // 辅助队列，用于BFS

    // 初始化：将根节点（0）的所有非空子节点加入队列，它们的失败指针都指向根节点。
    for (int i = 0; i < 10; i++) {
        if (tree[0][i]) { // 如果根节点通过数字i有子节点
            q.push(tree[0][i]); // 将该子节点入队
            // 根节点的子节点的失败指针自然指向根节点（0），因为没有更短的前缀可回溯。
            fail[tree[0][i]] = 0;
        }
    }

    while (!q.empty()) { // 当队列不为空时
        int u = q.front(); // 取出队首节点
        q.pop();           // 弹出队首节点

        // 遍历当前节点u的所有可能的出边（0-9）
        for (int i = 0; i < 10; i++) {
            if (tree[u][i]) { // 如果存在从节点u通过字符i到达的子节点tree[u][i]
                // 计算tree[u][i]的失败指针：它指向其父节点u的失败指针fail[u]通过相同字符i转移到的节点。
                fail[tree[u][i]] = tree[fail[u]][i];
                // 传播危险标记：如果当前节点的失败指针指向的节点是危险节点，那么当前节点也视为危险节点。
                // 这表示即使当前路径没有直接匹配禁止串，但通过回溯（失败指针）也能匹配到。
                alert[tree[u][i]] |= alert[fail[tree[u][i]]];
                q.push(tree[u][i]); // 将子节点入队，继续BFS
            } else { // 如果不存在从节点u通过字符i到达的子节点
                // 为了方便数位DP，将tree[u][i]指向其失败指针对应的节点通过字符i转移到的节点。
                // 这样，即使当前路径无法匹配，也能沿着失败指针继续匹配，保证状态机的完整性。
                tree[u][i] = tree[fail[u]][i];
            }
        }
    }
}

// === 数位DP核心函数 ===
// f1(i, j, free, has): 动态规划状态函数
// i: 当前处理到数字的第i位 (0-based index)
// j: 当前在AC自动机中的节点ID
// free: 自由选择标志 (0:受限, 1:自由)
// has: 是否已经有有效数字标志 (0:全是前导零/未选择, 1:已有有效数字)
int f1(int i, int j, int free, int has) {
    // 基础情况 1: 如果当前AC自动机节点j是危险节点（或其失败链上有危险节点），
    // 意味着我们已经匹配到了一个禁止子串。因此，这条路径是无效的，返回0。
    if (alert[j]) return 0;

    // 基础情况 2: 如果已经处理完所有数字位（i == n），
    // 意味着我们成功构建了一个完整的数字。
    // 如果has为1，说明这个数字是有效的（非前导零组成，或者至少包含一个非零数），返回1。
    // 如果has为0，说明构建的数字全是0（或者空），这不是一个有效的计数结果，返回0。
    if (i == n) return has;

    // 记忆化搜索：如果当前状态(i, j, free, has)已经计算过，直接返回之前的结果，避免重复计算。
    if (dp[i][j][free][has] != -1) return dp[i][j][free][has];

    int ans = 0; // 初始化当前状态的答案
    int cur = num[i] - '0'; // 获取当前位数字N[i]的实际值，作为上界

    if (!has) { // 情况1: 之前还未选择过任何有效数字（即当前前缀都是前导零，或者尚未选择任何数字）
        if (!free) { // 子情况1.1: 受限于N，且是前导零状态
            // 选项1: 继续选择0作为前导零。
            // 移动到下一位 (i+1)，AC自动机状态回到根节点 (0)，保持自由状态 (1) 因为0是不受限的，
            // 保持has为0（因为还是前导零）。
            // 注意：AC自动机状态在处理前导零时，通常会回溯到根节点，因为前导零不应参与模式匹配。
            // 这里的tree[j][pick]在pick=0且has=0时，如果j=0，则tree[0][0]通常就是0。
            // 但如果禁止串以0开头，那么tree[0][0]可能不是0。这里更安全且常见的处理是直接跳过AC状态，回到0。
            // 实际的实现中，为了简化，代码将前导零也通过tree[j][0]进行转移。
            // 如果你希望前导零不进入AC自动机匹配，那么f1(i + 1, 0, 1, 0)是正确的，意味着0不影响匹配状态。
            // 这里的f1(i + 1, 0, 1, 0) 是选择当前位为0，进入自由模式，has仍然为0。
            // 这部分处理“前导零”与“实际数字”的分界是数位DP的常见难点。
            // current_node = (pick == 0 && !has) ? 0 : tree[j][pick];  // 更严谨的前导零处理可能在这里
            ans = (ans + f1(i + 1, 0, 1, 0)) % MOD; // 选择0作为前导零，下一位进入自由模式，has仍为0。

            // 选项2: 选择1到cur-1之间的数字，开始一个有效数字
            for (int pick = 1; pick < cur; pick++) {
                // 选择pick后，下一位将进入自由模式 (1)，且has变为1 (已选择有效数字)
                ans = (ans + f1(i + 1, tree[j][pick], 1, 1)) % MOD;
            }
            // 选项3: 选择cur数字
            // 选择了cur，下一位仍可能受限 (0)，has变为1 (已选择有效数字)
            ans = (ans + f1(i + 1, tree[j][cur], 0, 1)) % MOD;
        } else { // 子情况1.2: 自由选择状态，且是前导零状态 (这种情况通常发生在已经比num小了)
            // 选项1: 继续选择0作为前导零
            ans = (ans + f1(i + 1, 0, 1, 0)) % MOD; // 状态同上，回到根节点（0），自由模式，has仍为0。
            // 选项2: 选择1到9的数字，开始一个有效数字
            for (int pick = 1; pick <= 9; pick++) {
                // 选择pick后，下一位仍是自由模式 (1)，且has变为1 (已选择有效数字)
                ans = (ans + f1(i + 1, tree[j][pick], 1, 1)) % MOD;
            }
        }
    } else { // 情况2: 之前已经选择过至少一个非零数字 (即当前前缀已经是一个有效数字)
        if (!free) { // 子情况2.1: 受限于N
            // 选项1: 选择0到cur-1之间的数字
            for (int pick = 0; pick < cur; pick++) {
                // 选择pick后，下一位将进入自由模式 (1)，has保持1 (已是有效数字)
                ans = (ans + f1(i + 1, tree[j][pick], 1, 1)) % MOD;
            }
            // 选项2: 选择cur数字
            // 选择了cur，下一位仍可能受限 (0)，has保持1
            ans = (ans + f1(i + 1, tree[j][cur], 0, 1)) % MOD;
        } else { // 子情况2.2: 自由选择状态
            // 选项1: 选择0到9的数字
            for (int pick = 0; pick <= 9; pick++) {
                // 选择pick后，下一位仍是自由模式 (1)，has保持1
                ans = (ans + f1(i + 1, tree[j][pick], 1, 1)) % MOD;
            }
        }
    }
    // 将当前状态的计算结果存储到dp表中，并返回。
    return dp[i][j][free][has] = ans;
}

// === 主函数 ===
int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false); // 关闭C++标准流与C标准流的同步
    cin.tie(0);                   // 解除cin和cout的绑定，使得cin不必等待cout刷新

    cin >> num; // 读取大数字N（上限）的字符串形式
    n = strlen(num); // 获取N的长度

    int m; // 禁止子串的数量
    cin >> m; // 读取禁止子串的数量

    // 初始化AC自动机相关数据结构
    memset(tree, 0, sizeof(tree));    // 将所有节点的孩子指针清零
    memset(fail, 0, sizeof(fail));    // 将所有失败指针清零
    memset(alert, false, sizeof(alert)); // 将所有危险标记清零
    cnt = 0;                          // 重置节点计数器

    // 读入并插入所有禁止串到AC自动机
    string s;
    while (m--) { // 循环m次
        cin >> s; // 读取一个禁止串
        insert(s); // 将其插入到AC自动机中
    }

    // 构建AC自动机的失败指针
    setFail();

    // 初始化DP表
    clear();

    // 调用数位DP核心函数f1，并输出结果
    // f1(0, 0, 0, 0) 的含义：
    // i=0: 从数字的第一位（最高位）开始处理
    // j=0: 初始AC自动机状态为根节点（无任何匹配）
    // free=0: 初始时，数字的选择受限于num[0]（因为还没开始构造比N小的数）
    // has=0: 初始时，还没有选择任何有效数字（即所有位都是前导零）
    cout << f1(0, 0, 0, 0) << endl;

    return 0; // 程序成功结束
}
