#include <iomanip> // 包含用于格式化输出的头文件，例如设置小数点精度
#include <iostream> // 包含用于输入输出的头文件，例如cin, cout
using namespace std; // 使用标准命名空间，避免每次都写std::
// collecting bugs
// 题目大意：一个软件有 s 个子系统，会产生 n 种 bug。某人一天发现一个 bug，这个 bug 属于某种 bug 分类，也属于某个子系统。每个 bug 属于某个子系统的概率是
//
// 1/s，属于某种 bug 分类的概率是
//
// 1/n。求发现 n 种 bug，且 s 个子系统都找到 bug 的期望天数。

int n, s; // 声明两个整数变量n和s，通常代表总行数/列数或总类别/总项数
double dp[1010][1010]; // 声明一个二维数组dp，用于存储动态规划的状态值，通常dp[i][j]表示从状态(i, j)达到目标状态所需的期望次数。
                      // 数组大小为1010x1010，足够处理n和s最大为1000的情况。

int main() {
    // 下面两行代码用于优化C++标准库的输入输出流，使其运行更快。
    // cin.tie(nullptr)解除cin和cout的绑定，sync_with_stdio(false)禁用C风格I/O与C++风格I/O的同步。
    cin.tie(nullptr)->sync_with_stdio(false);

    cin >> n >> s; // 读取n和s的值。根据问题上下文，n和s可能代表卡片或物品的总类别和总类型。

    // 动态规划的基准情况：当已经收集了n个类别和s个类型时，所需额外步数为0。
    // 这表示dp[n][s]是我们的目标状态，从这个状态到自身不再需要任何步数。
    dp[n][s] = 0;

    // 从目标状态(n, s)逆向计算到初始状态(0, 0)。
    // i代表当前已收集的类别数，j代表当前已收集的类型数。
    // 循环从n递减到0，s递减到0，确保计算dp[i][j]时，所有依赖的未来状态（dp[i+1][j], dp[i][j+1], dp[i+1][j+1]）都已计算完毕。
    for (int i = n; i >= 0; i--) {
        for (int j = s; j >= 0; j--) {
            if (i == n && s == j) continue; // 如果当前状态是dp[n][s]（基准情况），则跳过，因为已经赋值为0。

            // 动态规划状态转移方程的解释：
            // dp[i][j] 表示从状态(i, j)达到目标状态(n, s)的期望步数。
            // 考虑下一步可能发生的情况：
            // 1. 从已收集的 i 个类别和已收集的 j 个类型中抽到：概率为 (i * j) / (n * s)。
            //    状态保持在 (i, j)，期望步数是 dp[i][j]。
            // 2. 从已收集的 i 个类别中抽到，但从未收集的 (s - j) 个类型中抽到新类型：概率为 (i * (s - j)) / (n * s)。
            //    状态变为 (i, j + 1)，期望步数是 dp[i][j+1]。
            // 3. 从未收集的 (n - i) 个类别中抽到新类别，但从已收集的 j 个类型中抽到：概率为 ((n - i) * j) / (n * s)。
            //    状态变为 (i + 1, j)，期望步数是 dp[i+1][j]。
            // 4. 从未收集的 (n - i) 个类别和从未收集的 (s - j) 个类型中抽到新类别和新类型：概率为 ((n - i) * (s - j)) / (n * s)。
            //    状态变为 (i + 1, j + 1)，期望步数是 dp[i+1][j+1]。

            // 期望值的公式：E = Sum(P_k * E_k) + 1 （加1是因为进行了一步操作）
            // E = P1*E + P2*E2 + P3*E3 + P4*E4 + 1
            // 移项得到：E * (1 - P1) = P2*E2 + P3*E3 + P4*E4 + 1
            // E = (P2*E2 + P3*E3 + P4*E4 + 1) / (1 - P1)
            // 其中 P1 = (i * j) / (n * s)
            // (1 - P1) = 1 - (i * j) / (n * s) = (n * s - i * j) / (n * s)
            // 所以，分子是 (dp[i][j+1] * (i * (s - j)) + dp[i+1][j] * ((n - i) * j) + dp[i+1][j+1] * ((n - i) * (s - j)) + n * s)
            // 分母是 (n * s - i * j)
            // 注意：公式中各项的系数是对应事件的组合数，乘以期望值。
            // 最后加上 n * s 是因为每一步操作，总期望值都加1。为了消除分母 n*s，将各项概率都乘以 n*s，
            // 从而分子的 +1 变成了 + n*s。
            dp[i][j] = (dp[i][j + 1] * i * (s - j) + // 抽到现有类别+新类型，贡献值：dp[i][j+1] * 发生这种情况的组合数
                        dp[i + 1][j] * (n - i) * j + // 抽到新类别+现有类型，贡献值：dp[i+1][j] * 发生这种情况的组合数
                        dp[i + 1][j + 1] * (n - i) * (s - j) + // 抽到新类别+新类型，贡献值：dp[i+1][j+1] * 发生这种情况的组合数
                        n * s) / // 这一项是表示进行了1次操作的贡献，即期望值中额外的“1”，但此处分母是 n*s - i*j，所以分子要乘以 n*s
                       (n * s - i * j);  // 分母是所有“有用”抽样（即不抽到现有类别+现有类型）的组合数总和。
                                            // 或者从期望公式推导，分母是 1 - (i*j)/(n*s) 再乘以 n*s。
        }
    }
    // 输出结果，即从初始状态(0, 0)达到目标状态(n, s)所需的期望步数。
    // fixed和setprecision(4)用于将输出固定为小数形式，并设置小数点后四位精度。
    cout << fixed << setprecision(4) << dp[0][0] << '\n';
    return 0; // 程序正常结束。
}
