#include <iostream>
#include <algorithm>
#include <cstring>

// 从上到下挖砖块(展示动态规划思路，不优化枚举，不进行空间压缩)
// 一堆组成倒三角形状的砖埋在地里，一共有n层，第1层有n块砖，每层递减，类似如下数据
// 4 2 9 5
//  3 1 7
//   2 4
//    8
// 需要从第1层开始挖，每挖开一块砖都可以获得数值作为收益，第1层的砖可以随意挖
// 但是挖到下面的砖是有条件的，想挖i层的j号砖，你需要确保i-1层的(j、j+1)块砖已经被挖开
// 最多可以挖m块砖，返回最大的收益
// 1 <= n <= 50
// 1 <= m <= 1300
// 砖块数值 <= 100
// 测试链接 : https://www.luogu.com.cn/problem/P1437

using namespace std;

const int MAXN = 51;   // 最大层数
const int MAXM = 1301; // 最大挖掘砖块数量

int grid[MAXN][MAXN];      // 存储砖块的价值，grid[i][j]表示第i层第j个砖块的价值
int dp[MAXN][MAXN][MAXM];  // dp[i][j][k]表示在第i层挖到第j个砖块，总共挖了k个砖块时的最大收益
int n, m;                  // n是层数，m是最多可以挖的砖块数

int compute() {
   int ans = 0;  // 记录全局最大收益

   // 逐层处理，从第1层到第n层
   for (int i = 1; i <= n; i++) {
       int cur = 0;  // cur表示当前层从第0个砖块到第j个砖块的累计价值

       // 枚举当前层挖到第几个砖块（从0开始编号）
       for (int j = 0; j <= i; j++) {
           cur += grid[i][j];  // 累加当前砖块的价值

           // 想要挖到第i层第j个砖块，至少需要挖掘的砖块总数
           // 等差数列求和：1+2+...+j = j*(j+1)/2
           // 也就是说前面的层必须挖够对应数量的砖块才能到达这个位置
           for (int k = (j + 1) * j / 2; k <= m; k++) {
               int maxVal = 0;  // 记录上一层的最大收益

               // 枚举上一层可能的挖掘位置
               // 要挖当前层的第j个砖块，上一层必须挖到第j-1或第j个砖块
               // 因为砖块是倒三角形排列的
               for (int p = max(0, j - 1); p <= i - 1; p++) {
                   // dp[i-1][p][k-j]表示：
                   // 上一层挖到第p个砖块，总共挖了k-j个砖块时的最大收益
                   // k-j是因为当前层要挖j个砖块，所以上一层只能挖k-j个
                   maxVal = max(maxVal, dp[i - 1][p][k - j]);
               }

               // 状态转移：当前状态的收益 = 上一层的最大收益 + 当前层的累计收益
               dp[i][j][k] = maxVal + cur;

               // 更新全局最大收益
               ans = max(ans, dp[i][j][k]);
           }
       }
   }
   return ans;
}

int main() {
   // 优化输入输出速度
   ios::sync_with_stdio(false);
   cin.tie(nullptr);

   // 读入层数n和最多挖掘数量m
   cin >> n >> m;

   // 按列读入砖块价值
   // 第j列有n-j+1个砖块，从第n行到第j行
   for (int j = 1; j <= n; j++) {
       for (int i = n; i >= j; i--) {
           cin >> grid[i][j];
       }
   }

   // 输出最大收益
   cout << compute() << endl;

   return 0;
}

/*
算法思路说明：
1. 这是一个动态规划问题，状态定义为dp[i][j][k]表示在第i层挖到第j个砖块，总共挖了k个砖块时的最大收益
2. 砖块排列成倒三角形，每层的砖块数递减，挖掘有依赖关系
3. 要挖第i层第j个砖块，必须先挖掉第i-1层的第j或第j-1个砖块
4. 时间复杂度：O(n^3 * m)，空间复杂度：O(n^2 * m)
5. cur变量用于累计当前层从第0个到第j个砖块的总价值，避免重复计算

输入格式示例：
4 2 9 5
3 1 7
 2 4
  8
表示4层砖块，每层的价值如上所示
*/
