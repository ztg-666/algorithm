#include <vector>
#include <algorithm>

// 送箱子到码头的最少行程数
// 一共有m个码头，编号1 ~ m， 给定长度为n的二维数组boxes
// boxes[i][0]表示i号箱子要送往的码头，boxes[i][1]表示i号箱子重量
// 有一辆马车，一次最多能装a个箱子并且箱子总重量不能超过b
// 马车一开始在仓库，可以在0位置，马车每开动一次，认为行程+1
// 箱子必须按照boxes规定的顺序被放上马车，也必须按照顺序被送往各自的码头
// 马车上相邻的箱子如果去往同一个码头，那么认为共享同一趟行程
// 马车可能经过多次送货，每次装货需要回到仓库，认为行程+1，送完所有的货，最终要回到仓库，行程+1
// 返回至少需要几个行程能把所有的货都送完
// 所有数据的范围 <= 10^5
// 测试链接 : https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/

using namespace std;

class Solution {
public:
    // 贪心分析 + 窗口优化，只用有限几个变量维护窗口信息，无需单调队列/单调栈
    int boxDelivering(vector<vector<int>>& boxes, int m, int a, int b) {
        int n = boxes.size();

        // dp[i] : 马车拉完前i个货物并回仓库，需要的最少行程
        // 注意这里的i是指个数，对应的货物是boxes[0...i-1]
        // 例如: dp[3]表示拉完boxes[0], boxes[1], boxes[2]三个货物需要的最少行程
        vector<int> dp(n + 1);

        // 基础情况：拉完第一个货物需要2个行程
        // 1个行程：从仓库到码头送货
        // 1个行程：从码头回到仓库
        dp[1] = 2;

        // 滑动窗口的左右边界，维护马车最后一趟的货物范围[l...r]
        // weight: 最后一趟货物的总重量
        // trip: 最后一趟需要的行程数
        int weight = boxes[0][1];  // 初始只有第一个货物的重量
        int trip = 2;              // 初始行程：去+回 = 2

        // 从第二个货物开始遍历，r表示当前考虑的货物索引
        for (int l = 0, r = 1; r < n; r++) {
            // 将当前货物加入最后一趟
            weight += boxes[r][1];

            // 如果当前货物和前一个货物的目的地不同，需要额外的行程
            // 因为马车需要先去前一个码头，再去当前码头
            if (boxes[r][0] != boxes[r - 1][0]) {
                trip++;
            }

            // 窗口收缩的三个条件（任何一个满足就需要收缩）：
            // 1) 最后一趟货物的个数超了（超过马车容量a）
            // 2) 最后一趟货物的总重量超了（超过马车载重b）
            // 3) 贪心优化：如果dp[l] == dp[l+1]，说明第l个货物可以"免费"分给前面的趟次
            //    因为分给前面不会增加总行程，所以应该分出去以减少当前趟次的负担
            while (r - l + 1 > a || weight > b || dp[l] == dp[l + 1]) {
                // 将左边界的货物从当前趟次中移除
                weight -= boxes[l][1];
                l++;  // 左边界右移

                // 如果移除的货物和下一个货物目的地不同，需要减少一个行程
                // 因为现在不需要在这两个不同的码头之间移动了
                if (boxes[l][0] != boxes[l - 1][0]) {
                    trip--;
                }
            }

            // 状态转移：dp[r+1] = dp[l] + trip
            // dp[l]：完成前l个货物的最少行程
            // trip：最后一趟[l...r]需要的行程
            // dp[r+1]：完成前r+1个货物的最少行程
            dp[r + 1] = dp[l] + trip;
        }

        // 返回完成所有n个货物需要的最少行程
        return dp[n];
    }
};

/*
算法思路总结：
1. 使用动态规划 + 滑动窗口优化
2. dp[i]表示完成前i个货物需要的最少行程
3. 维护一个滑动窗口[l, r]表示马车最后一趟的货物范围
4. 对于每个位置r，尝试将其加入最后一趟，然后调整窗口左边界l
5. 窗口调整的三个条件确保了贪心策略的正确性
6. 时间复杂度：O(n)，每个元素最多被访问两次（一次加入窗口，一次移出窗口）
7. 空间复杂度：O(n)，dp数组的空间
*/
